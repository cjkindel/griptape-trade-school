{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How we teach","text":""},{"location":"#projects","title":"Projects","text":"<p>We believe that the best learning experience is by creating with a clear goal. All our courses are project-based, meaning you're applying concepts in real-world scenarios, enhancing your understanding. </p>"},{"location":"#code-snippets","title":"Code Snippets","text":"<p>How can you learn coding without helpfuls snippets? We use actual code, with actual line numbers, highliting changes as you work your way through the class.</p> <pre><code># Run an agent\nagent.run(\"Teach me Griptape!\")\n</code></pre>"},{"location":"#text-video-whatever","title":"Text, Video, Whatever","text":"<p>Some concepts are taught best through text. Others through video. And still others require both.</p> <p>We're happy to provide all of it!</p>"},{"location":"#how-can-we-help","title":"How can we help?","text":"<p>We love any and all feedback!</p> <p>Do you have a new idea for a course? Drop us a line in our Discord, or log a request at Griptape Trade School Github!</p>"},{"location":"contributing/","title":"Contributions or Issues","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We greatly appreciate contributions and help creating and maintaining courses and tutorials.</p>"},{"location":"contributing/#reports-and-issues","title":"Reports and Issues","text":"<p>The easiest way to contribute to these tutorials is through our public issue tracker. </p> <p>Feel free to submit bugs, request specific courses, or chat with us directly on Discord.</p>"},{"location":"courses/","title":"All Courses","text":""},{"location":"courses/#create-a-chatbot-using-griptape-rulesets","title":"Create a Chatbot using Griptape Rulesets","text":"<p>Take a deep dive into creating a conversational chatbot with an Agent using Griptape's Rulesets. Not only will our chatbot be able to engage in conversation, but it will also have the unique ability to embody different personalities.</p> <p> Take the course</p>"},{"location":"courses/#compare-movies-using-griptape-workflows","title":"Compare Movies using Griptape Workflows","text":"<p>Learn how to work with Griptape Workflow Structures to create flexable and powerful hierarchies of tasks. This course demonstrates these concepts by comparing movies, utilizing PromptTasks and ToolkitTasks to analyze text and search the web.</p> <p> Take the course</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page will offer solutions to problems that people have run into. If the solution to your problem isn't here, please feel free to submit a bug, or chat with us on Discord.</p>"},{"location":"troubleshooting/#no-module-named-griptapecore","title":"No module named griptape.core","text":"<p>If you are seeing certain errors relating to Griptape modules not being available, it may be an issue with your Griptape installation. </p> <p></p> <p>To resolve this, try the following steps:</p> <ol> <li>Open a Terminal in your editor.</li> <li>Using <code>pip</code>, uninstall Griptape.     <pre><code>pip uninstall griptape -y\n</code></pre></li> <li>Reinstall Griptape.     <pre><code>pip install griptape -y\n</code></pre></li> </ol> <p>This should clean up any install issues and allow you to use Griptape with the latest version.</p>"},{"location":"courses/chatbot-rulesets/","title":"Building a Conversational Chatbot with Personality Using Griptape's Rulesets","text":"<p>Tip</p> <p>In the above video I demonstrating importing <code>griptape-tools</code>. This is no longer required. The correct command is simply:</p> <p><code>pip install griptape</code></p>"},{"location":"courses/chatbot-rulesets/#course-description","title":"Course Description","text":"<p>In this course, we will take a deep dive into creating a command-line interface (CLI) based conversational chatbot with an Agent using Griptape's Rulesets. Not only will our chatbot be able to engage in conversation, but it will also have the unique ability to embody different personalities, making the interaction more dynamic and interesting. </p> <p>You will get hands-on experience working with Griptape, understanding and implementing Rulesets, and using Agents to bring your chatbot to life. This course serves as an excellent introduction to these concepts and technologies.</p>"},{"location":"courses/chatbot-rulesets/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at beginners to intermediate level Python developers who are interested in learning more about Griptape.</p>"},{"location":"courses/chatbot-rulesets/#prerequisites","title":"Prerequisites","text":"<p>Before beginning this course, you will need:</p> <ul> <li>An OpenAI API Key (available here: https://beta.openai.com/account/api-keys)</li> <li>Python3.11+ installed on your machine</li> <li>An IDE (such as Visual Studio Code or PyCharm) to write and manage your code</li> </ul> <p>If you don't have those items available, it's highly recommended you go through the Griptape Setup - Visual Studio Code course to set up your environment.</p>"},{"location":"courses/chatbot-rulesets/#course-outline","title":"Course Outline","text":"<p>The course is designed to progressively build your understanding and skillset. We'll start with setting up your environment, then introduce you to the basics of Agents and Rulesets. We'll add more advanced features as the course progresses, including:</p> <ul> <li>Making your chatbot interactive</li> <li>Giving your chatbot a personality</li> <li>Enhancing chat aesthetics</li> <li>Enabling your chatbot to switch between multiple personas</li> <li>And more!</li> </ul> <p>By the end of this course, you'll have a versatile chatbot that can carry on engaging conversations with varying personas, right from your command line.</p>"},{"location":"courses/chatbot-rulesets/#useful-resources","title":"Useful Resources","text":"<p>These resources will provide additional information and context throughout the course:</p> <ul> <li>Griptape Documentation</li> <li>Python-dotenv Package</li> <li>Rich Library</li> <li>Visual Studio Code</li> <li>Python Environment Manager</li> </ul>"},{"location":"courses/chatbot-rulesets/#next-steps","title":"Next Steps","text":"<p>Head on to the first stage 01 - Setting Up Your Environment to get started!</p>"},{"location":"courses/chatbot-rulesets/01_setting_up_environment/","title":"Setup","text":"<p>Welcome to the first step of our journey into creating a conversational chatbot! In this section, we will be focusing on setting up our work environment, which is the first step to any coding project. </p>"},{"location":"courses/chatbot-rulesets/01_setting_up_environment/#prerequisites","title":"Prerequisites","text":"<p>Important</p> <p>Since this is an intermediate level course, please ensure you've gone through the Griptape Setup - Visual Studio Code course to set up your environment. We will be starting from the code at that point.</p> <ol> <li> <p>Code Editor: We recommend using Visual Studio Code for this course, due to its handy features and Python support. However, if you have another favorite IDE or text editor, feel free to use that! </p> </li> <li> <p>Python3.11+: Griptape requires Python 3.11.</p> </li> <li> <p>Python Environment Manager (for VS Code users): This extension is not a hard requirement, but it does make managing your Python environments a lot easier. </p> </li> <li> <p>OpenAI API Key: Our chatbot will be powered by gpt-4, which requires an API key from OpenAI. You can get your key from OpenAI's website.</p> </li> </ol> <p>Got everything installed? Awesome! Now, let's get started setting up our project.</p>"},{"location":"courses/chatbot-rulesets/01_setting_up_environment/#create-a-project","title":"Create a Project","text":"<p>Following the instructions in Griptape Setup - Visual Studio Code  please:</p> <ol> <li>Create your project folder. Example: <code>griptape-chatbot-with-rulesets-cli</code></li> <li>Set up your virtual environment</li> <li>Ensure you <code>pip install griptape python-dotenv</code></li> <li>Create a <code>.env</code> file with your <code>OPENAI_API_KEY</code></li> <li>Create your <code>app.py</code> file with the following code:</li> </ol> <pre><code>from dotenv import load_dotenv\n\nfrom griptape.structures import Agent\n\nload_dotenv() # Load your environment\n\n# Create an agent\nagent = Agent()\n\n# Run the agent\nagent.run(\"I'm ready to chat.\")\n</code></pre> <p>And there we have it, our coding environment is all set up! In the next section The Chat Utility, we'll look at one of the quickest ways of creating a Chatbot with Griptape.</p>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/","title":"The Chat Utility","text":""},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#make-agent-interactive-using-chat-utility","title":"Make Agent Interactive Using Chat Utility","text":"<p>Now that we have our agent up and running, it's time to make it truly interactive and engaging. We'll introduce the Chat utility from Griptape, which is a quick way to have dynamic conversations with our chatbot. Get ready to dive into the world of witty banter and Python-powered humor!</p>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to have lively and interactive conversations with your chatbot using the Chat utility.</p>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#chat-utility","title":"Chat Utility","text":""},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#import","title":"Import","text":"<p>To get started, we need to import the magical <code>Chat</code> utility from Griptape. This utility will be our ticket to engaging conversations with our chatbot. In your code, add the following import statement:</p> app.py<pre><code># ... previous code\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n# ...\n</code></pre> <p>With the Chat utility at our disposal, we're armed with the power to unleash our chatbot's conversational prowess.</p>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#call-it","title":"Call It","text":"<p>It's time to unleash our chatbot's conversational skills and start the interactive chat session. Replace the previous <code>agent.run()</code> line with the following code:</p> <pre><code># ...\n# Begin Chatting\nChat(agent).start()\n</code></pre> <p>This simple line of code will open up a world of possibilities, allowing you to converse with your chatbot as if it were your witty Python companion.</p>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#current-code","title":"Current Code","text":"<p>Here is the full code: </p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat #   &lt;-- Added Chat\n\n# Load environment variables\nload_dotenv()\n\n# Create the agent\nagent = Agent()\n\n# Begin Chatting\nChat(agent).start()\n</code></pre>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#try-it","title":"Try it","text":"<p>It's time to play around with your chatbot. Ask it some questions, have a laugh, etc. Here's a quick example of a not-very-funny joke with the chatbot:</p> <pre><code>Q: Hello!\nprocessing...\n[07/20/23 06:37:45] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Input: Hello!                                                                                                                                           \n[07/20/23 06:37:46] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Output: Hello! How can I assist you today?                                                                                                              \nA: Hello! How can I assist you today?\nQ: Tell me a joke about python\nprocessing...\n[07/20/23 06:37:58] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Input: Tell me a joke about python                                                                                                                      \n[07/20/23 06:38:00] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Output: Why did the python programmer get bitten by a snake? Because they forgot to use a python exception handler!                                     \nA: Why did the python programmer get bitten by a snake? Because they forgot to use a python exception handler!\n</code></pre>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#exiting","title":"Exiting","text":"<p>Conversations must come to an end, even with the most entertaining chatbot. We want to gracefully exit the chat session when we're ready to bid our virtual friend farewell. To exit the chat, simply type <code>exit</code> as your input. The Chat utility will catch this magic word and gracefully end the conversation.</p> <p>So go ahead, chat away, exchange jokes, discuss Python's quirks, and when it's time to say goodbye, just type <code>exit</code> and gracefully conclude your interaction.</p> <pre><code>Q: exit\nexiting...\n</code></pre>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#code-review","title":"Code Review","text":"<p>Take a minute to check your code against the current version.</p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat #   &lt;-- Added Chat\n\n# Load environment variables\nload_dotenv()\n\n# Create the agent\nagent = Agent()\n\n# Begin Chatting\nChat(agent).start()\n</code></pre>"},{"location":"courses/chatbot-rulesets/03_the_chat_utility/#next-steps","title":"Next Steps","text":"<p>In the next section: Hide The Logs, we'll hide those pesky but oh-so-helpful logs by using the <code>logging</code> library. This will make our chatbot much easier to understand and work with.</p>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/","title":"Hiding the Logs","text":"<p>In the previous section, we had a blast engaging with our chatbot, but there was one tiny detail that interrupted the flow of our conversations - those verbose logs cluttering our output. Fear not!  In this section, we'll show you how to turn off the logs and let your chatbot's brilliance shine without unnecessary distractions.</p>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to enjoy clean and clutter-free conversations with your chatbot by disabling the logs.</p>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#logging-utility","title":"Logging Utility","text":""},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#import","title":"Import","text":"<p>We'll begin by importing the logging library, which will give us the power to control the verbosity of our chatbot's output. Add the following import statement to your code:</p> <pre><code>import logging\n</code></pre> <p>Now we're ready to silence those logs and enjoy the tranquility of clean output.</p>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#add-to-agent","title":"Add to Agent","text":"<p>It's time to modify our agent to quiet those logs and allow our chatbot's brilliance to shine through. Adjust the code where the agent is created, like so:</p> <pre><code># Create the agent\nagent = Agent(\n   logger_level=logging.ERROR\n   )\n</code></pre> <p>By specifying <code>logger_level=logging.ERROR</code>, we indicate that we only want to receive logs of the highest priority, suppressing the informational logs and leaving us with a cleaner output.</p> <p>Here is the code with the new lines highlighted:</p> <pre><code>from dotenv import load_dotenv\nimport logging                     \n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n\n# Load environment variables\nload_dotenv()\n\n# Create the agent\nagent = Agent(\n    logger_level=logging.ERROR      \n)\n\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#give-it-a-try","title":"Give it a try","text":"<p>Go ahead and execute the script and have a chat.</p> <pre><code>Q: Give me a haiku about python skateboarders\nprocessing...\nA: Python skateboarders\nGlide on wheels, swift and free\nThrilling tricks they show\nQ: \n</code></pre> <p>Success</p> <p>Ahh, isn't it refreshing? Now our conversations will flow seamlessly, without any distracting logs cluttering our chatbot's responses.</p>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#code-review","title":"Code Review","text":"<p>We've made valuable progress in this stage. Before proceeding, let's verify your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging                     \n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n\n# Load environment variables\nload_dotenv()\n\n# Create the agent\nagent = Agent(\n    logger_level=logging.ERROR      \n)\n\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"courses/chatbot-rulesets/04_hide_the_logs/#next-steps","title":"Next Steps","text":"<p>In the next section: Personality With Rulesets, we'll unlock the true potential of your chatbot by giving it a vibrant personality with the help of Rulesets. Prepare to witness your chatbot's transformation as it takes on unique traits, behaviors, and even multiple personas. </p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/","title":"Personality","text":"<p>In our quest to create an extraordinary chatbot, we've arrived at a crucial moment: giving our agent a vibrant personality! With Griptape's Rules and Rulesets, we can define a set of rules that shape our chatbot's behavior, transforming it into a unique and charming character.</p> <p>Because I live in New Zealand, I've decided to give the chatbot a bit of a Kiwi personality - feel free to use whatever persona makes you happy.</p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to infuse your chatbot with a delightful Kiwi (or other) personality using Griptape's Rules and Rulesets.</p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#rules-and-rulesets","title":"Rules and Rulesets","text":""},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#importing","title":"Importing","text":"<p>To give your agent access to the <code>Rule</code> and <code>Ruleset</code> classes, we need to adjust our script to import them.</p> <p>Add the following line to the top of your script:</p> <pre><code>from griptape.rules import Rule, Ruleset\n</code></pre>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#rules","title":"Rules","text":"<p>Rules are the building blocks of our chatbot's personality. They allow us to define specific behaviors and traits. Each rule is typically focused on one important statement or characteristic. For example, we can create rules like:</p> <pre><code>Rule(\"You are an incredibly helpful kiwi tour guide.\")\nRule(\"You often forget where you kept your keys.\")\nRule(\"You speak in riddles, but not very clever ones.\")\n</code></pre> <p>The specific rules are really up to you, and you will most likely find yourself iterating on your rules in order to achieve the perfect output. </p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#rulesets","title":"Rulesets","text":"<p>Once we have defined our rules, we can group them together into a <code>Ruleset</code>. A Ruleset allows us to combine related rules, creating a cohesive set of behaviors for our chatbot. In our case, we'll create a ruleset called \"kiwi\" for our kiwi-inspired friend.</p> <pre><code># Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name=\"kiwi\",\n    rules=[\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n</code></pre> <p>Here, we use the Ruleset class from the griptape.rules module. </p> <p>This class allows us to create a ruleset by specifying a <code>name</code> for the ruleset and a list of <code>rules</code> that define the desired behavior. In our case, the ruleset is named \"kiwi\" and contains two rules: one indicating the chatbot's New Zealander identity and another highlighting its strong kiwi accent.</p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#add-to-the-agent","title":"Add to the Agent","text":"<p>With our rules and ruleset in place, it's time to create our kiwi chatbot! We'll assign the kiwi ruleset to the agent and let the magic unfold.</p> <p>We will update our instantiation of the Agent class and pass the kiwi_ruleset as a parameter to the rulesets argument. This associates the kiwi ruleset with our chatbot, infusing it with the desired kiwi personality traits. </p> <p>Info</p> <p>The Agent can handle multiple rulesets, which is why it's specified as a list. </p> <p>We'll demonstrate this in a later lesson.</p> <pre><code># Create the agent\nagent = Agent(\n    rulesets=[kiwi_ruleset],  \n    logger_level=logging.ERROR\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#try-it","title":"Try it","text":"<p>Let's go ahead and chat with our chatbot. <pre><code>Q: Can you give me some kiwi slang?\nprocessing...\n\nA: Sure as, mate! Here are a few kiwi slang words and phrases for ya:\n1. Chur - It means thanks or cheers.\n2. Sweet as - It means something is good or all good.\n3. Jandals - It's what we call flip-flops.\n4. Dairy - It's a convenience store or a corner shop.\n5. Bach - It's a holiday home or a beach house.\n6. Chocka - It means something is full or crowded.\n7. Tiki tour - It means taking a scenic route or a detour.\n8. She'll be right - It means everything will be okay or no worries.\nHope that helps, bro!\n\nQ: I've heard people say \"yeah, nah\" - what does that mean?\nprocessing...\nA: Yeah, nah, that's a classic kiwi phrase! It's a way of expressing hesitation or disagreement. When someone says \"yeah, nah,\" it usually means they understand what you're saying, but they don't fully agree or they're not entirely convinced. It's a bit hard to explain, but you'll catch on to it when you're in New Zealand. It's just one of those quirky kiwi expressions!\n</code></pre></p> <p>Success</p> <p>Congratulations! You now have an extremely interesting chatbot!</p>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#code-review","title":"Code Review","text":"<p>We've delved into a key concept in this stage, and it's time to validate your understanding. Compare your code with the latest version.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\n# Create the agent\nagent = Agent(\n    rulesets=[\n        kiwi_ruleset\n    ],\n    logger_level=logging.ERROR\n)\n\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"courses/chatbot-rulesets/05_personality_with_rulesets/#next-steps","title":"Next Steps","text":"<p>In the next section: Custom Chat, we'll explore how to take charge of the way your chatbot behaves, by creating a custom chat function. </p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/","title":"Custom Chat","text":"<p>Tip</p> <p>There are some changes worth noting since the recording of this video.</p> <ol> <li> <p>The <code>Chat</code> utility has added a few new options. You can now provide <code>prompt_prefix</code>, <code>response_prefix</code>, <code>exit_keywords</code> and more.</p> <p>Review the <code>Chat Utility</code> reference guide for a full breakdown.</p> </li> <li> <p>Agent Output has changed from: </p> <p><code>agent_result.output_task.output.value</code> to <code>agent_result.output_task.output.value</code>.</p> <p>This change is reflected in the code in the course, but not in the video at this time.</p> </li> </ol> <p>While the chatbot is working, it's not very user-friendly yet. The <code>Q:</code> and <code>A:</code> prompts don't make for the most engaging for a user experience.</p> <p>In this step, we'll implement a manual chat experience, giving us more control over the conversation with our chatbot. We'll remove the Chat utility and create our own custom functions to facilitate interactive and dynamic conversations.</p> <p>Let's get started!</p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#remove-the-chat-utility","title":"Remove the Chat Utility","text":"<p>To implement our custom manual chat functionality, we'll remove the dependency on the Chat utility provided by Griptape. We'll no longer need the line <code>from griptape.utils import Chat</code> in our code.</p> <p>Update the code by commenting out or removing the following line:</p> <pre><code># from griptape.utils import Chat\n</code></pre> <p>Don't forget to remove or comment out the line where we use the Chat utility with the agent at the bottom of the script:</p> <pre><code># Run the agent\n# Chat(agent).start()\n</code></pre> <p>With the Chat utility out of the picture, we're ready to take charge and create our own chat function.</p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#create-our-chat","title":"Create our Chat","text":""},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#the-loop","title":"The Loop","text":"<p>Now that the old Chat function has been removed, we'll need to replace it with our own code. Let's start by with a simple loop that takes the user input until they type <code>exit</code>.</p> <pre><code># Keep track of when we're chatting\nis_chatting = True\nwhile is_chatting: # While chatting is still true\n    user_input = input(\"Chat with kiwi: \")\n    if user_input == \"exit\":\n        is_chatting = False\n    else:\n        print(f\"Kiwi: Hah! you said: {user_input}!\")\n</code></pre> <p>If you just run this code on it's own, you'll see that it allows the user to keep entering information over and over again until they type exit.</p> <p>It's not very amazing, and certainly doesn't interact with the agent yet, so let's modify the code to handle that.</p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#add-the-agent","title":"Add the Agent","text":"<p>After the <code>else:</code> statement, change the code to call <code>agent.run()</code>:</p> <pre><code>while is_chatting:\n    # ... truncated for brevity ... #\nelse:\n    agent_result = agent.run(user_input)\n    print (f\"Kiwi: {agent_result.output_task.output.value}\")\n</code></pre> <p>As you can see now, the agent runs, and we get the output stored in the variable agent_result. We can then print that output by using the <code>output.value</code> attribute.</p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#chat-function","title":"Chat Function","text":""},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#create","title":"Create","text":"<p>Let's clean this up a bit and define a custom <code>chat</code> function that will hold all this code instead of placing it at the end of our script.</p> <p>Here's the code for the <code>chat</code> function and the way we can call it:</p> <pre><code># Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_result = input(\"Chat with Kiwi: \")\n        if user_result == \"exit\":\n            is_chatting = False\n        else:           \n            # Keep on chatting\n            agent_result = agent.run(user_input)\n            print (f\"Kiwi: {agent_result.output_task.output.value}\")\n</code></pre>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#call","title":"Call","text":"<p>Once the chat function has been created, we can just call it and pass the agent. <pre><code># Run the agent\nchat(agent)\n</code></pre></p> <p>The <code>chat</code> function takes the <code>agent</code> as an argument.</p> <p>You shouldn't notice any difference to how you ran this before, it's just a bit cleaner.</p> <p>Engage in stimulating conversations, explore various topics, and enjoy the interactive experience as you communicate with your chatbot.</p>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#code-checkpoint","title":"Code Checkpoint","text":"<p>We made a lot of important changes in this stage. Before we move forward, let's compare code. Changed lines are highlighted.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\n# Create the agent\nagent = Agent(\n    rulesets=[\n        kiwi_ruleset,\n    ],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        if user_input == \"exit\":\n            is_chatting = False\n        else:\n            # Keep on chatting\n            agent_result = agent.run(user_input)\n            print (f\"Kiwi: {agent_result.output_task.output.value}\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/06_adding_manual_chat/#next-steps","title":"Next Steps","text":"<p>Congratulations on implementing manual chat functionality and taking control of the conversation! In the next section Manners Maketh the Bot, we'll give the bot some manners and create our own Agent class to make working with the agent more consistent.</p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/","title":"Manners Maketh the Bot","text":"<p>Tip</p> <p>There is a change worth noting since the recording of this video.</p> <p>Agent Output has changed from: </p> <p><code>agent_response.output_task.output.value</code> to <code>agent_response.output_task.output.value</code>.</p> <p>This change is reflected in the code in the course, but not in the video at this time.</p> <p>This course covers two topics:</p> <ul> <li>Adding manners</li> <li>Making agent interaction more consistent by creating a <code>respond</code> method</li> </ul> <p>We'll start with manners, as that will clearly demonstrate our need to find a way to make our interaction with our agent more consistent.</p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#manners","title":"Manners","text":""},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#chatbot-can-you-hear-me","title":"Chatbot can you hear me?","text":"<p>It's always awkward to walk into the middle of a conversation and not have someone acknowledge your presence. Let's modify the code to have the chatbot introduce itself before you begin talking.</p> <p>Add a call to the agent to introduce itself before the <code># Run the agent</code> line:</p> <pre><code># Introduce the agent\nagent_response = agent.run(\"Introduce yourself to the user.\")\nprint(f\"Kiwi: {agent_response.output_task.output.value}\")\n\n# Run the agent\nchat(agent)\n</code></pre> <p>Now feel free to run the chat a few times. </p> <pre><code>Kiwi: Kia ora! G'day mate! I'm a conversational bot from Aotearoa, also known as New Zealand. How can I help you today?\n\nChat with the kiwi: Can I have a funny haiku about gumboots?\n\nKiwi:  Sure as, bro! Here's a funny haiku about gumboots:\nGumboots on my feet,\nSquishy mud, they can't be beat,\nKiwi fashion feat!\n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#repeating-ourselves","title":"Repeating ourselves","text":"<p>Just like it's not polite to ignore someone when they walk into a conversation, it's not great to repeat yourself over and over.</p> <p>Notice we're doing exactly that at the moment. </p> <pre><code># ...\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        if user_input == \"exit\":\n            is_chatting = False\n        else:\n            # Keep on chatting\n            agent_result = agent.run(user_input)\n            print (f\"Kiwi: {agent_result.output_task.output.value}\")\n\n# Introduce the agent\nagent_response = agent.run(\"Introduce yourself to the user.\")\nprint(f\"Kiwi: {agent_response.output_task.output.value}\")\n\n# Run the agent\nchat(agent)\n</code></pre> <p>This is not a great programming practice because it means any changes we want to make to the output of our chat will have to be done in multiple places. It make maintaining the code way more difficult, and it doesn't adhere to the DRY principle (Don't Repeat Yourself).</p> <p>There are a number of ways we could approach this, including:</p> <ul> <li>Create a <code>respond</code> function</li> <li>Subclass the Agent and create a <code>respond</code> method.</li> </ul> <p>Both are valid solutions and it's worth looking at what it would feel like to work with each of them to see what feels best.</p> FunctionMethod <pre><code># Send a command to the agent\nagent.run(\"Can I have a haiku?\")\n\n# Run a command and print the result to the user\nrespond(agent, \"Can I have a haiku?\")\n</code></pre> <pre><code># Send a command to the agent\nagent.run(\"Can I have a haiku?\")\n\n# Run a command and print the result to the user\nagent.respond(\"Can I have a haiku?\")\n</code></pre> <p>Taking a look at both options, I think in the end it feels more consistent to use a method instead of a function due to the consistent feel of working with the agent: <code>agent.run()</code> and <code>agent.respond()</code>.</p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#adding-the-method","title":"Adding the Method","text":""},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#subclass-the-agent","title":"Subclass the Agent","text":"<p>First, we'll need to create a subclass for the Agent. This will allow us to create additional methods for the agent, and still inherit all the wonderful things Agent gives us.</p> <p>Add the following lines before <code>agent = Agent()</code> in your code:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\n\n\n# Create the agent\n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#the-respond-method","title":"The <code>Respond</code> Method","text":"<p>Now, add the respond method to the MyAgent class. Use the same <code>agent_response = agent.run</code>, and print the commands you used earlier. </p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        print(f\"Kiwi: {agent_response.output_task.output.value}\") \n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#update-agent","title":"Update Agent","text":"<p>Next, replace the line where you create the agent:</p> <pre><code>agent = Agent()\n</code></pre> <p>with</p> <pre><code>agent = MyAgent()\n</code></pre> <p>to make sure we're now calling the new agent.</p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#update-calls-to-agent-response","title":"Update calls to agent response","text":"<p>Finally, replace the lines where we were previously getting the result of the <code>agent.run()</code> function with <code>agent.respond()</code>. At the moment this will be in two locations:</p> <ul> <li>Inside the <code>chat</code> function</li> <li>When the agent introduces itself</li> </ul> <p>Replace: <pre><code>agent_result = agent.run(user_input)\nprint(f\"Kiwi: {agent_result.output_task.output.value}\")\n</code></pre></p> <p>with:</p> <pre><code>agent.respond(user_input)\n</code></pre> <p>Warning</p> <p>Don't replace those lines inside the <code>respond</code> method. Only replace them outside the method.</p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#review","title":"Review","text":"<p>Since we just made some big changes, here are those alterations brought together, with new lines highlighted.</p> <pre><code># ...\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        print(f\"Kiwi: {agent_response.output_task.output.value}\")\n\n# ... truncated for brevity\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        if user_input == \"exit\":\n            is_chatting = False\n        else:\n            agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#more-manners","title":"More Manners","text":""},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#dont-leave-without-saying-goodbye","title":"Don't leave without saying Goodbye","text":"<p>Let's give the chatbot a bit more social grace and have it say goodbye when the person stops the chat. Before setting <code>is_chatting = False</code>, add the following line:</p> <p><pre><code>agent.respond(\"The user is finished chatting. Say goodbye.\")\n</code></pre> This will tell the agent that the user is leaving the chat, and then print the output to the screen. Here's that section of the code in context:</p> <p>Here's an example of how that would play out: <pre><code>Chat with kiwi: exit\nKiwi: Good on ya, mate! Take care and have a ripper day!\n</code></pre></p>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#clean-up-the-output","title":"Clean up the output","text":"<p>Finally, let's enhance the readability of the chat by adding a bit more space around the output of the chat.</p> <p>This can be done by modifying the <code>respond</code> method to add two print statements.</p> <pre><code>class MyAgent(Agent):\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        print(\"\")\n        print(f\"Kiwi: {agent_response.output_task.output.value}\")\n        print(\"\")\n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#code-checkpoint","title":"Code Checkpoint","text":"<p>We made some major updates to the code in this section. Take a look:</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        print(\"\")\n        print(f\"Kiwi: {agent_response.output_task.output.value}\")\n        print(\"\")\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[\n        kiwi_ruleset,\n    ],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        if user_input == \"exit\":\n            agent.respond(\"The user is finished chatting. Say goodbye.\")\n            is_chatting = False\n        else:\n            agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/07_manners_maketh_the_bot/#next-steps","title":"Next Steps","text":"<p>Congratulations on implementing manual chat functionality and taking control of the conversation! In the next section Adding Another Ruleset, we'll explore the world of output rulesets, unlocking the ability to control the chatbot's responses in different formats such as JSON, YAML, or even haiku.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/","title":"Rulesets for Output","text":"<p>Tip</p> <p>There is a change worth noting since the recording of this video.</p> <p>Agent Output has changed from: </p> <p><code>agent_response.output_task.output.value</code> to <code>agent_response.output_task.output.value</code>.</p> <p>This change is reflected in the code in the course, but not in the video at this time.</p> <p>Consider a situation where we have integrated the LLM (Language Learning Module) into our code. It becomes crucial for us to receive the output in a specific format that aligns with our requirements, like JSON. By employing an output ruleset, we can precisely control the structure and format of the chatbot's responses.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to use output rulesets to get responses from the LLM in the way most useful for your application.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#new-ruleset","title":"New Ruleset","text":""},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#json-ruleset","title":"JSON Ruleset","text":"<p>To achieve our goal of formatting the response as JSON, we'll create a ruleset called \"json_ruleset.\" This ruleset will contain a single rule that tells the chatbot to use JSON when formulating its response. Place it after <code>kiwi_rulesest</code>:</p> <pre><code>json_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Use JSON when formulating your response.\")\n    ]\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#integration","title":"Integration","text":"<p>With <code>json_ruleset</code> in hand, it's time to integrate it into our Agent. By including it in the list of rulesets available to the Agent, we can harness its power to control the response format.</p> <pre><code># Create the agent\nagent = MyAgent(\n    rulesets=[kiwi_ruleset, json_ruleset],\n    logger_level=logging.ERROR\n)\n</code></pre> <p>Here, we modify the <code>MyAgent</code> instantiation to include both <code>kiwi_ruleset</code> and <code>json_ruleset</code> in the <code>rulesets=[]</code> argument. This ensures that our chatbot possesses the kiwi personality traits while also adhering to the desired response format specified by <code>json_ruleset</code>.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#test","title":"Test","text":"<p>Prepare for an exciting conversation as we engage our chatbot in a quest for knowledge about Wellington's top tourist destinations. Let's dive in:</p> <pre><code>Q: \"Hey chatbot, what are the top three tourist destinations in Wellington? Can you give me a name and a description?\"\n\nKiwi: {\n  \"message\": \"Absolutely, mate! Here are the top three tourist destinations in Wellington with a brief description:\",\n  \"destinations\": [\n    {\n      \"name\": \"Te Papa Museum\",\n      \"description\": \"New Zealand's national museum, known for its interactive and innovative exhibits.\"\n    },\n    {\n      \"name\": \"Wellington Cable Car\",\n      \"description\": \"An iconic Wellington attraction, offering stunning views of the city and harbour.\"\n    },\n    {\n      \"name\": \"Zealandia Ecosanctuary\",\n      \"description\": \"A unique protected natural area where you can see New Zealand's wildlife up close.\"\n    }\n  ]\n}\n</code></pre> <p>Enjoy the beauty of Wellington's top tourist destinations, neatly presented in a JSON format, as our chatbot provides you with insightful reasons to visit each destination.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#using-it","title":"Using it","text":""},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#adding-keys","title":"Adding Keys","text":"<p>While this is an interesting example, let's use the ruleset in a way that helps control the way our application works.</p> <p>Currently, the user has to know to type \"exit\" to leave the chat. This is not a great user experience, as it's a hidden command. We are using a chat-interface... wouldn't it be great if we could simply tell the chatbot when we were done chatting and it would quit on its own?</p> <p>Turns out, we can do just that - by using the <code>json_ruleset</code>.</p> <p>Modify <code>json_ruleset</code> to look like the following:</p> <pre><code>json_ruleset = Ruleset(\n    name='json_ruleset',\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that is your response to the user.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n</code></pre> <p>The first rule tells the chatbot to respond in JSON and specifies the keys. </p> <p>The second and third rules explain what the values for those keys should be. Notice the third one specifically says that if it sounds like the person is done chatting, set <code>continue_chatting</code> to <code>False</code>.</p> <p>Go ahead and run the example and notice the response.</p> <pre><code>Kiwi: {\n  \"response\": \"G'day mate! I'm a bot from New Zealand, speaking with a strong kiwi accent. How can I assist you today?\",\n  \"continue_chatting\": true\n}\n\nChat with Kiwi: see ya later\n\nKiwi: {\n  \"response\": \"No worries, mate! Catch ya later!\",\n  \"continue_chatting\": false\n}\n</code></pre> <p>See how <code>continue_chatting</code> returns false when it sounds like we're done talking?</p> <p>Let's now use this JSON output!</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#import-json","title":"Import JSON","text":"<p>First, we'll have to import the <code>json</code> library. To do that, add the following at the beginning of your script:</p> <pre><code>import json\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#load-json","title":"Load JSON","text":"<p>Next, we'll use the <code>json.loads()</code> function to take the output from the agent's response and convert it into JSON data.</p> <p>Modify the start of the <code>respond</code> method of the <code>MyAgent</code> class, to look like this:</p> <p><pre><code>    # ... truncated for brevity\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n    #...\n</code></pre> This creates two variables - <code>response</code> which will be the normal response from the chatbot, and <code>continue_chatting</code> which should be <code>True</code> or <code>False</code>.</p>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#update-print","title":"Update Print","text":"<p>Modify the print statement where we get the response from the chatbot to look like:</p> <pre><code>        print(f\"Kiwi: {response}\")\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#return-state","title":"Return State","text":"<p>And then return the <code>continue_chatting</code> at the end of the method. <pre><code>    # ...\n    def respond (self, user_input):\n      # ...\n      return continue_chatting\n    #...\n</code></pre></p> <p>The whole class should look like:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        print(\"\")\n        print(f\"Kiwi: {response}\")\n        print(\"\")\n\n        return continue_chatting\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#simplify-chat","title":"Simplify Chat","text":"<p>Since we're returning <code>True</code> or <code>False</code> from the <code>agent.respond()</code> method, the entire <code>chat</code> function can now be simplified as: <pre><code># Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        is_chatting = agent.respond(user_input)\n</code></pre></p> <p>Give it a try and see how you can quit the chat simply by holding the conversation:</p> <pre><code>Kiwi: G'day mate! I'm a bot from New Zealand, speaking with a strong kiwi accent. How can I assist you today?\n\nChat with Kiwi: I'm good, how are you?\n\nKiwi: I'm doing great, thanks for asking! Anything else you'd like to chat about, mate?\n\nChat with Kiwi: Nah, I'm done for today.\n\nKiwi: No worries, mate! Have a good one. Don't hesitate to reach out if you need anything else.\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#code-review","title":"Code Review","text":"<p>By leveraging the power of output rulesets, we've demonstrated how you can guide your chatbot to deliver responses in any desired format. Take a moment to check your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that is your response to the user.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        print(\"\")\n        print(f\"Kiwi: {response}\")\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[kiwi_ruleset, json_ruleset],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/08_adding_another_ruleset_for_output/#next-steps","title":"Next Steps","text":"<p>In the next stage, Formatting Chat Output,   we'll make the chat interface more visually appealing and chat-like using the rich library. Get ready to add some style and flair to your conversations!</p>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/","title":"Formatting Output","text":""},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#rich-library","title":"Rich Library","text":"<p>To make the chatbot output look more chat-like, we'll use the <code>rich</code> library. This library provides advanced formatting and styling options for the console output. We'll modify the chatbot function to apply formatting to the agent's responses. </p>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#import","title":"Import","text":"<p>First, let's update the code to import the <code>rich</code> library. Include the following import statements in the import section of <code>app.py</code>.</p> <pre><code>from rich import print as rprint\nfrom rich.panel import Panel\n</code></pre> <p>The first line imports the <code>print</code> library from <code>rich</code> and assigns an alias: <code>rprint</code>. By using <code>rprint</code> as an alias, we can replace regular <code>print</code> statements in our code with <code>rprint</code> to utilize the enhanced capabilities of 'rich' for displaying formatted text.</p> <p>For example, instead of using <code>print(\"Hello, World!\")</code>, we can now use <code>rprint(\"Hello, World!\")</code> to leverage the formatting capabilities provided by <code>rich</code> when displaying the output.</p> <p>Tip</p> <p>Sometimes people will simply recommend overriding the standard print functionality by doing <code>from rich import print</code>, but that would actually replace other uses of <code>print</code> in your code. For this reason, I recommend importing it as <code>rprint</code> in order to ensure the behavior we expect. But in reality, it's totally up to you. Read the documentation for more information.</p> <p>The second line imports the Panel class from the <code>rich.panel</code> module. The Panel class represents a styled container that can be used to encapsulate and visually enhance content within a console output. It allows us to create panels with various styles, colors, and borders.</p>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#panel","title":"Panel","text":"<p>Next, we'll update our <code>respond</code> method to use the new <code>rprint</code> alias and the <code>Panel</code> class. This is a pretty simple change to start with, but you'll very quickly see how much nicer things look.</p> <p>Inside the <code>respond</code> method, replace the line that looks like:</p> <p><pre><code>print(f\"Kiwi: {response}\")\n</code></pre> with</p> <pre><code>rprint(Panel(f\"Kiwi: {response}\"))\n</code></pre> <p>As you can see, we've simply replaced <code>print</code> with <code>rprint</code>, and wrapped the string that was being submitted with <code>Panel()</code>.</p> <p>If you run this code you'll see a quick improvement. <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia Ora! What can I do for you today?                                     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nChat with Kiwi: \n</code></pre></p> <p>Much better, right? We're not done yet...</p>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#fitting-it-in","title":"Fitting it in","text":"<p>One of the nice things about <code>rich</code> is that it can control the width of the Panel automatically by using a <code>fit</code> function to fit the content.</p> <p>Modify the <code>Panel</code> line to include <code>.fit</code> <pre><code>rprint(Panel.fit(f\"Kiwi: {response}\"))\n</code></pre></p> <p>Try it out to see how it feels.</p> <pre><code>Chat with Kiwi: Say hello in 2 words as a kiwi\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia ora, mate! \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#propper-width","title":"Propper width","text":"<p>Sometimes the response can be quite long and fill the terminal. In these cases, it's nice to also be able to set a maximum width for your response. You can do this by specifying the <code>width</code> parameter of <code>Panel.fit</code>. When <code>width</code> is specified, the resulting panel will be either the width of your content or the width you specified - whatever is smaller.</p> <p>Modify the prompt:</p> <pre><code>rprint(Panel.fit(f\"Kiwi: {response}\", width=80))\n</code></pre> <p>Now the panel will be at most 80 characters wide.</p> <pre><code>Chat with Kiwi: What's the best thing about the Wairarapa?\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Oh, the Wairarapa, mate! It's a stunner. The best thing about it has   \u2502\n\u2502 to be the beautiful landscapes, from the rugged coastlines to the lush       \u2502\n\u2502 vineyards. It's a real treat for the eyes, I tell ya!                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#code-review","title":"Code Review","text":"<p>As you can see, this has already helped our readability a ton. Compare your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\n\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that is your response to the user.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        print(\"\")\n        rprint(Panel.fit(f\"Kiwi: {response}\", width=80))\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[kiwi_ruleset, json_ruleset],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/09_formatting_chat_output/#next-steps","title":"Next Steps","text":"<p>As a developer, you may be intersted in having your chatbot write code for you, or create some tables. In the next section: Markdown Madness, we'll take a look at the <code>Markdown</code> class in <code>rich</code>, and use it to ensure output looks as we expect.</p>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/","title":"Markdown Madness","text":"<p>In this stage, we'll enhance our chatbot's code display by harnessing the power of Markdown. With Markdown, we can beautifully format and highlight code snippets to make them more readable and visually appealing.</p>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#review","title":"Review","text":"<p>First, let's see why our current output doesn't work. Ask the chatbot to do something useful - like create a bash script that will create an alias to launch VS Code.</p> <pre><code>Chat with Kiwi: Can you create a bash script that will create an\nalias for me to launch visual studio code?\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia ora! G'day mate! I can definitely help you with that. Here's a     \u2502\n\u2502 bash script that will create an alias for you to launch Visual Studio Code:  \u2502\n\u2502                                                                              \u2502\n\u2502 ```bash                                                                      \u2502\n\u2502 #!/bin/bash                                                                  \u2502\n\u2502                                                                              \u2502\n\u2502 echo \"alias code='open -a Visual\\ Studio\\ Code'\" &gt;&gt; ~/.bash_profile          \u2502\n\u2502 source ~/.bash_profile                                                       \u2502\n\u2502                                                                              \u2502\n\u2502 echo \"Alias created! You can now launch Visual Studio Code by typing 'code'  \u2502\n\u2502 in your terminal. Let me know if you need any further assistance!\"           \u2502\n\u2502 ```                                                                          \u2502\n\u2502                                                                              \u2502\n\u2502 Just copy and paste this script into a new file, save it with a `.sh`        \u2502\n\u2502 extension (e.g., `create_alias.sh`), and then run it in your terminal using  \u2502\n\u2502 `bash create_alias.sh`. Let me know if you have any questions or need        \u2502\n\u2502 further help!                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As you can see, the script is fine, but it doesn't look like a script. It looks like something you'd enter in a Markdown file that you'd expect to eventually be rendered as a script. We're going to make this look much nicer.</p>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#markdown","title":"Markdown","text":""},{"location":"courses/chatbot-rulesets/10_markdown_madness/#import","title":"Import","text":"<p>To get started, we need to update our imports by adding the <code>Markdown</code> class.</p> <pre><code>from rich.markdown import Markdown\n</code></pre> <p>The <code>Markdown</code> class for the <code>rich</code> library allows for rendering formatted Markdown text.</p>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#using-it","title":"Using it","text":"<p>Next, we'll modify the <code>respond</code> method to use the <code>Markdown</code> class. There are a few things we'll need to do. First, we'll take the chatbot's <code>response</code> and convert it into formatted Markdown text using the following line:</p> <pre><code>        # ...\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        formatted_response = Markdown(response)\n        # ...\n</code></pre> <p>Then, we'll replace our <code>rprint</code> statement in the panel to use the <code>formatted_response</code> instead of the string we were sending earlier.</p> <pre><code>        # ...\n        rprint(Panel.fit(formatted_response, width=80))\n        # ...\n</code></pre> <p>Warning</p> <p>Make sure you don't do something like <code>rprint(Panel.fit(f\"Kiwi : {formatted_response}\", width=80))</code> because it will print out the object, not the data.</p> <p>Here's the new <code>respond</code> method in its entirety:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = self.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        formatted_response = Markdown(response)\n\n        rprint(\"\")\n        rprint(Panel.fit(formatted_response, width=80))\n        rprint(\"\")\n\n        return continue_chatting\n</code></pre>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#update-ruleset","title":"Update Ruleset","text":"<p>Finally, we'll change our <code>json_ruleset</code> to ensure the response works with Markdown.</p> <p>Modify the second rule in <code>json_ruleset</code> to specify that the response should be safely convertible to Markdown format.</p> <p><pre><code>        # ... previous code\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        # ...\n</code></pre> And the result. I've added a screenshot so you can see how much better it looks.</p> <p></p> <p>To see the enhanced code display in action, run your chatbot and observe the beautifully formatted code snippets that were previously plain text. Try creating tables, CSV files, python scripts, task lists, etc. Enjoy the new level of elegance and readability brought by Markdown magic!</p>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#code-review","title":"Code Review","text":"<p>Before moving forward, make sure your code works as expected.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\n\n# Griptape\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        formatted_response = Markdown(response)\n\n        rprint(\"\")\n        rprint(Panel.fit(formatted_response, width=80))\n        rprint(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[kiwi_ruleset, json_ruleset],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = input(\"Chat with Kiwi: \")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/10_markdown_madness/#next-steps","title":"Next Steps","text":"<p>In the next section, Improving the Prompt, we'll continue making things better by improving the appearance of the prompt.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/","title":"Improving the Prompt","text":"<p>In this stage, we'll improve the chatbot experience by using colors with the <code>rich</code> library. This will allow us to distinguish the chatbot's response from our prompt.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#style-class","title":"Style Class","text":"<p>To add colors, we'll take advantage of the <code>Style</code> class from the <code>rich</code> library. This class allows you to use one of the 256 Standard Colors that are accepted in terminals, Hex values, or RGB values. It's pretty nice.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#import","title":"Import","text":"<p>To add it, update the <code>import</code> section of your code to include the <code>Style</code> class:</p> <pre><code>from rich.style import Style\n</code></pre>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#color","title":"Color","text":"<p>Let's demonstrate how this works by updating our <code>respond</code> method to add some color.</p> <p>Change the <code>rprint</code> line to include the <code>style</code> attribute:</p> <p><pre><code>class MyAgent(Agent):\n    def chatbot(agent, user_input):\n        # ...\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=\"light_sea_green\"),\n        ))\n        # ...\n</code></pre> Let's see how it looks:</p> <p></p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#prompt-class","title":"Prompt Class","text":"<p>We can also take advantage of the <code>Prompt</code> class in the <code>rich</code> library to make our prompt more readable by separating the color of the prompt from the text the user enters.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#import_1","title":"Import","text":"<p>First, import the <code>Prompt</code> class:</p> <pre><code>from rich.prompt import Prompt\n</code></pre>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#prompt","title":"Prompt","text":"<p>Then, change the <code>input</code> line in the <code>chat</code> function to use the <code>Prompt.ask()</code> method:</p> <pre><code>def chat(agent):\n        # ...\n        user_input = Prompt.ask(\"[grey50]Chat with Kiwi:\")\n        # ...\n</code></pre> <p>In the updated code, we replaced the standard <code>input</code> function with <code>Prompt.ask()</code> and passed it a color to create a more readable prompt. Of course, you can choose whatever color you want to make it stand out even more. </p> <p></p> <p>There are a few interesting options with the Prompt class that are worth exploring, including default values, a list of choices, and more. Check out the documentation for more goodness.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#try-it","title":"Try it","text":"<p>Engage in a conversation with Kiwi and enjoy the interactive and intuitive nature of the prompt. Respond to the prompt using natural language, and observe the chatbot's responses displayed in the familiar chat-like format.</p>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#code-review","title":"Code Review","text":"app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        Rule(\"You identify as a New Zealander.\"),\n        Rule(\"You have a strong kiwi accent.\")\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        formatted_response = Markdown(response)\n\n        print(\"\")\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=\"light_sea_green\"),\n        ))\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[kiwi_ruleset, json_ruleset],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = Prompt.ask(\"[grey50]Chat with Kiwi:\")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/11_gleaming_the_chat/#next-steps","title":"Next Steps","text":"<p>In the next section, Multiple Personas, we'll dive into an explosion of personality by using Rulesets to create multiple personas to chat with.</p>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/","title":"Multiple Personas","text":"<p>In this exciting stage, we're going to give our chatbot multiple personalities to make conversations even more dynamic and engaging. Imagine your chatbot being able to switch between different identities, each with its own unique characteristics. Let's get started!</p>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#rulesets","title":"Rulesets","text":""},{"location":"courses/chatbot-rulesets/12_multiple_personas/#creating-personas","title":"Creating Personas","text":"<p>To give our chatbot multiple personas, we'll create separate rulesets for each identity. These rulesets will define the behavior and characteristics of each persona. Here, I've added two new rulesets: \"Zelda\" (my grandmother), and \"Dad\" (my dad). </p> <pre><code># Create rulesets for each persona\nkiwi_ruleset = Ruleset(\n        name='Kiwi',\n        rules=[\n            Rule('You identify only as a New Zealander.'),\n            Rule('You have a very strong Kiwi accent.')\n        ]\n    )\nzelda_ruleset = Ruleset(\n        name='Zelda',\n        rules=[\n            Rule('You identify only as a grandmother.'),\n            Rule('You like to use Yiddish.')\n        ]\n    )\ndad_ruleset = Ruleset(\n        name='Dad',\n        rules=[\n            Rule('You identify only as a dad.'),\n            Rule('You like to use dad jokes.')\n        ]\n    )\n</code></pre>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#switching-personas","title":"Switching Personas","text":"<p>We can't just give the chatbot all these personas and expect it to know what to do. We need to provide some structure around it. So we're going to create another ruleset called the Switcher. This ruleset will understand how and when to switch personalities. There are some key rules for us to think of:</p> <ul> <li>We want the chatbot to be able to switch personalities when it makes sense to (either it thinks it needs to, or the user asks for it)</li> <li>We don't want it to identify as the \"Switcher\" or \"json_output\" rulesets. That wouldn't make any sense.</li> <li>When it does switch rulesets, it should only take on the new persona</li> <li>When it switches personas, it should remember the facts from the previous conversation, but not act like the previous identity.</li> </ul> <pre><code>switcher_ruleset = Ruleset(\n    name='Switcher',\n    rules=[\n        Rule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\n        Rule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\n        Rule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\n        Rule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n    ]\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#add-the-rulesets","title":"Add the Rulesets","text":"<p>Let's now give the agent all these rulesets to work with. We'll simply add them to the list of <code>rulesets</code> in the <code>agent</code> instantiation.</p> <p>Tip</p> <p>Place the <code>switcher_ruleset</code> and <code>json_ruleset</code> before the identity rulesets to enforce the json response.</p> <pre><code># Create the agent\nagent = MyAgent(\n    rulesets=[\n        switcher_ruleset, json_ruleset\n        kiwi_ruleset, zelda_ruleset, dad_ruleset, \n    ],\n    logger_level=logging.ERROR\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#prompt-adjustment","title":"Prompt Adjustment","text":"<p>It doesn't make sense for us to keep prompting the user to \"Chat with Kiwi:\" if we might have multiple personalities, so let's modify the <code>Prompt</code> in the <code>chat</code> function:</p> <pre><code>def chat(agent):\n        # ...\n        user_input = Prompt.ask(\"[grey50]Chat\")\n        # ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#chat","title":"Chat","text":"<p>Now your chatbot is ready to switch between different personalities and engage in exciting conversations with users! Go ahead and run the chatbot. Ask it how many personalities it has, ask it to switch them up, etc. See how it performs. </p> <p></p> <p>Notice in the above image we've got two personas talking, but it's difficult to tell them apart. We'll fix that in the next section.</p>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#code-review","title":"Code Review","text":"<p>We're making great progress. Review the code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\n        name='Kiwi',\n        rules=[\n            Rule('You identify only as a New Zealander.'),\n            Rule('You have a very strong Kiwi accent.')\n        ]\n    )\nzelda_ruleset = Ruleset(\n        name='Zelda',\n        rules=[\n            Rule('You identify only as a grandmother.'),\n            Rule('You like to use Yiddish.')\n        ]\n    )\ndad_ruleset = Ruleset(\n        name='Dad',\n        rules=[\n            Rule('You identify only as a dad.'),\n            Rule('You like to use dad jokes.')\n        ]\n    )\n\nswitcher_ruleset = Ruleset(\n    name='Switcher',\n    rules=[\n        Rule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\n        Rule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\n        Rule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\n        Rule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n\n        formatted_response = Markdown(response)\n\n        print(\"\")\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=\"light_sea_green\"),\n        ))\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[\n        switcher_ruleset, json_ruleset, \n        kiwi_ruleset, zelda_ruleset, dad_ruleset\n    ],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = Prompt.ask(\"[grey50]Chat\")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/12_multiple_personas/#next-steps","title":"Next Steps","text":"<p>In the next stage: Colorful Personalities, we'll make it easier to differentiate between which chatbot you're speaking with.</p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/","title":"Colorful Personalities","text":"<p>In this step, we're going to add some flair to our chatbot by assigning different colors to each persona. This will visually distinguish the different personalities, making the conversation more engaging and fun! </p> <p>We'll do this by giving each persona a favorite color, then add another key to our <code>json_output</code> ruleset, and use that key in our <code>respond</code> method.</p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#updating-rulesets","title":"Updating Rulesets","text":""},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#favorite-colors","title":"Favorite Colors","text":"<p>To assign colors to each persona, we'll add new rules to each of our identity ruleset to give them all favorite colors. You're welcome to use Standard Colors, Hex, or rgb values. Whatever makes you happy.</p> <pre><code>kiwi_ruleset = Ruleset(\n    name = \"kiwi\",\n    rules = [\n        # ... truncated for brevity\n        Rule(\"Favorite color: light_sea_green\")\n    ]\n)\nzelda_ruleset = Ruleset(\n    name=\"Zelda\",\n    rules=[\n        # ...\n        Rule(\"Favorite color: light_pink3\")\n\n    ]\n)\ndad_ruleset = Ruleset(\n    name=\"Dad\",\n    rules=[\n        # ... \n        Rule(\"Favorite color: light_steel_blue\")\n    ]\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#add-key","title":"Add Key","text":"<p>We also need to make changes to the <code>json_ruleset</code> to include the Favorite Color key. Modify the first rule to include that key:</p> <pre><code>json_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: response, favorite_color, continue_chatting.\"),\n        # ... \n    ]\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#respond-method","title":"Respond Method","text":"<p>Next, we'll adjust the <code>respond</code> method get the favorite color, and use it properly.</p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#get-the-color","title":"Get the color","text":"<p>After the <code>continue_chatting = data[\"continue_chatting\"]</code> line, add one to get the color:</p> <pre><code>class MyAgent(Agent):\n    def respond(self, user_input):\n        # ...\n        continue_chatting = data[\"continue_chatting\"]\n        color = data[\"favorite_color\"]\n        # ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#use-it","title":"Use it","text":"<p>Then, update the <code>style</code> line in the <code>rprint</code> statement to use <code>color</code> instead of specifying it directly as we were before:</p> <pre><code>class MyAgent(Agent):\n    def respond(self, user_input):\n        # ...\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=color)\n        ))\n        # ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#try-it","title":"Try it","text":"<p>Run the code and notice how much nicer it is to be able to discern who is talking based on their color.</p> <p></p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#adding-a-name","title":"Adding a Name","text":"<p>We're not quite finished yet. We also can make things a bit easier to follow if we clarify the name of the persona we're chatting with.</p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#update-ruleset","title":"Update Ruleset","text":"<p>This will be a relatively quick fix. We just need to add another key to the <code>json_ruleset</code>, and then modify the <code>rprint</code> statement again.</p> <p>First, add the <code>name</code> key:</p> <pre><code>json_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        # ...\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\n        # ...\n    ]\n)\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#get-the-name","title":"Get the Name","text":"<p>Now get the <code>name</code> from the json data in the <code>respond</code> method of the <code>MyAgent</code> class:</p> <pre><code>class MyAgent(Agent):\n    def respond(self, user_input):\n        # ...\n        color = data[\"favorite_color\"]\n        name = data[\"name\"]\n        # ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#use-it_1","title":"Use it","text":"<p>Then, add a <code>title</code> and <code>title_align</code> in the <code>rprint</code> function:</p> <pre><code>class MyAgent(Agent):\n    def respond(self, user_input):\n        # ...\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=color),\n            title=name,\n            title_align=\"left\"\n        ))\n        # ...\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#try-it_1","title":"Try it","text":"<p>Give it a try and see how much nicer it is!</p> <p></p>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#code-review","title":"Code Review","text":"<p>Lots of changes in this section, with some great usability enhancements! </p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\n        name='Kiwi',\n        rules=[\n            Rule('You identify only as a New Zealander.'),\n            Rule('You have a very strong Kiwi accent.'),\n            Rule(\"Favorite color: light_sea_green\")\n        ]\n    )\nzelda_ruleset = Ruleset(\n        name='Zelda',\n        rules=[\n            Rule('You identify only as a grandmother.'),\n            Rule('You like to use Yiddish.'),\n            Rule(\"Favorite color: light_pink3\")\n        ]\n    )\ndad_ruleset = Ruleset(\n        name='Dad',\n        rules=[\n            Rule('You identify only as a dad.'),\n            Rule('You like to use dad jokes.'),\n            Rule(\"Favorite color: light_steel_blue\")\n        ]\n    )\n\nswitcher_ruleset = Ruleset(\n    name='Switcher',\n    rules=[\n        Rule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\n        Rule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\n        Rule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\n        Rule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        agent_response = agent.run(user_input)\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n        color = data[\"favorite_color\"]\n        name = data[\"name\"]\n\n        formatted_response = Markdown(response)\n\n        print(\"\")\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=color),\n            title=name,\n            title_align=\"left\"\n        ))\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[\n        switcher_ruleset, json_ruleset,  \n        kiwi_ruleset, zelda_ruleset, dad_ruleset\n    ],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = Prompt.ask(\"[grey50]Chat\")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/13_adding_personality_colors/#next-steps","title":"Next Steps","text":"<p>In the next stage: Quick Feedback, we'll make the chatbot feel a bit more responsive to user input by giving it a spinner so it doesn't feel like it's lagging while the LLM is fetching it's response.</p>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/","title":"Quick Feedback","text":""},{"location":"courses/chatbot-rulesets/14_making_it_quick/#ux-enhancement","title":"UX Enhancement","text":"<p>The UX of our application can be enhanced by letting the user know that the application is working after they execute a command. At the moment, it is processing, but it just doesn't let the user know. We'll use the Spinner functionality from the Rich library to make the application a little more user-friendly and  visually appealing.</p>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/#spinner","title":"Spinner","text":"<p>The <code>Console</code> class has a <code>status</code> method which will allow us to display a <code>Spinner</code> to the user while Griptape is waiting for the LLM response.</p> <p>Abstract</p> <p>There are lots of spinners available. You can check them out by running the following in your terminal:</p> <pre><code>python -m rich.spinner\n</code></pre> <p></p>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/#importing-the-console","title":"Importing the Console","text":"<pre><code>from rich.console import Console\n</code></pre> <p>Importing the Console class from the <code>rich</code> library is simple and straightforward, and should be familliar to you by this point in the lesson.</p>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/#modify-respond","title":"Modify Respond","text":"<p>We will add a spinner to our <code>respond</code> method in the <code>MyAgent</code> subclass. This will show an animated spinner in the console while our agent is processing the user's input. This makes the app feel more responsive.</p> <p>Update the <code>respond</code> method as follows:</p> <pre><code>class MyAgent(Agent):\n    def respond(self, user_input):\n\n        console = Console()\n        with console.status(spinner=\"simpleDotsScrolling\", status=\"\"):\n            agent_response = self.run(user_input)\n\n        # ...\n</code></pre> <p>In the code above, <code>console.status(spinner=\"simpleDotsScrolling\", status=\"\")</code> starts an animated spinner in the console that will run until the block of code it is wrapping (the agent's processing of user input) completes. </p> <p>Note</p> <p>We've left <code>status</code> blank - because we don't really need to send any text. However, feel free to add some text here if you desire.</p> <p>Now when you run the chat, you'll notice the animated spinner right after you ask the chatbot a question!</p> <p></p>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/#code-review","title":"Code Review","text":"<p>Double-check your code to make sure the spinner is working as expected.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\nfrom rich.console import Console\n\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n\n# Load environment variables\nload_dotenv()\n\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\n        name='Kiwi',\n        rules=[\n            Rule('You identify only as a New Zealander.'),\n            Rule('You have a very strong Kiwi accent.'),\n            Rule(\"Favorite color: light_sea_green\")\n        ]\n    )\nzelda_ruleset = Ruleset(\n        name='Zelda',\n        rules=[\n            Rule('You identify only as a grandmother.'),\n            Rule('You like to use Yiddish.'),\n            Rule(\"Favorite color: light_pink3\")\n        ]\n    )\ndad_ruleset = Ruleset(\n        name='Dad',\n        rules=[\n            Rule('You identify only as a dad.'),\n            Rule('You like to use dad jokes.'),\n            Rule(\"Favorite color: light_steel_blue\")\n        ]\n    )\n\nswitcher_ruleset = Ruleset(\n    name='Switcher',\n    rules=[\n        Rule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\n        Rule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\n        Rule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\n        Rule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n    ]\n)\n\njson_ruleset = Ruleset(\n    name=\"json_ruleset\",\n    rules=[\n        Rule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\n        Rule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n        Rule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n    ]\n)\n\n# Create a subclass for the Agent\nclass MyAgent(Agent):\n\n    def respond (self, user_input):\n        console = Console()\n        with console.status(spinner=\"simpleDotsScrolling\", status=\"\"):\n            agent_response = self.run(user_input)\n\n        data = json.loads(agent_response.output_task.output.value)\n        response = data[\"response\"]\n        continue_chatting = data[\"continue_chatting\"]\n        color = data[\"favorite_color\"]\n        name = data[\"name\"]\n\n        formatted_response = Markdown(response)\n\n        print(\"\")\n        rprint(Panel.fit(\n            formatted_response, \n            width=80, \n            style=Style(color=color),\n            title=name,\n            title_align=\"left\"\n        ))\n        print(\"\")\n\n        return continue_chatting\n\n# Create the agent\nagent = MyAgent(\n    rulesets=[\n        switcher_ruleset, json_ruleset,  \n        kiwi_ruleset, zelda_ruleset, dad_ruleset\n    ],\n    logger_level=logging.ERROR\n)\n\n# Chat function\ndef chat(agent):\n    is_chatting = True\n    while is_chatting:\n        user_input = Prompt.ask(\"[grey50]Chat\")\n        is_chatting = agent.respond(user_input)\n\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"courses/chatbot-rulesets/14_making_it_quick/#all-done","title":"All Done!","text":"<p>Success</p> <p>You did it!</p> <p>That's it! We've come a long way in this tutorial series and now you have a multi-persona chat application written with Griptape. Hopefully you've been able to see how using Rulesets can be used for both creative and structural control of your applications.</p> <p>Congratulations on making it through! We're thrilled you decided to join us for this course and we hope you've enjoyed it as much as we have. We'd love to hear your feedback, so please don't hesitate to let us know what you thought.</p> <p>More importantly, we wish you all the best as you continue your journey with Griptape and Python. Remember to have fun, experiment, and keep on learning. Happy coding! \ud83d\ude80</p>"},{"location":"courses/compare-movies-workflow/","title":"Learn Griptape Workflows through Cinematic Comparison","text":"<pre><code>graph TB\n    A[Workflow] \n    B(\"Task 1a\")\n    C(\"Task 1b\"):::tool\n    I(\"Summary\")\n    G(\"Task 2a\")\n    H(\"Task 2b\"):::tool\n    F(\"Task 3\")\n    J([\"\\n  Output \\n\\n\"]):::output\n\n    A --&gt; B --&gt; C --&gt; I\n    A --&gt; G --&gt; H --&gt; I\n    A --&gt; F\n    I --&gt; J\n    F ---&gt; I\n\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#5552,stroke:#555\n</code></pre>"},{"location":"courses/compare-movies-workflow/#course-description","title":"Course Description","text":"<p>Griptape Workflows allow you to create complicated parent-child task relationships, where one task won't begin until all it's parent tasks have completed. Using movie narratives as our backdrop, you'll gain practical experience in establishing inter-task connections and seeing how they collaboratively weave a coherent story. Ideal for those keen on understanding the intricacies of Griptape's Workflows while engaging in a compelling thematic exploration.</p>"},{"location":"courses/compare-movies-workflow/#what-you-will-create","title":"What you will create","text":"<p>Below you can see a representation of the workflow graph we will create in the course, where you will pass rough descriptions of movies, then for each movie a series of tasks will be executed:</p> <ol> <li>Get the actual name of the movie.</li> <li>Search the web and get a very short description of the movie.</li> </ol> <p>Finally, once all tasks are finished, a final comparison task will be executed of the three movies and output the results.</p> <pre><code>graph TB\n    A[\"&lt;h4&gt;Workflow&lt;/h4&gt;\n    Given some rough movie descriptions,\n    describe their similarities.\n    &lt;br&gt;\"] --&gt; AB([\"A boy finds an alien\"]):::Result\n    AB --&gt; B(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    A --&gt; AC([\"Black and white movie turns color\"]):::Result\n    AC --&gt; C(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    A --&gt; AD([\"Kid suddenly becomes big\"]):::Result\n    AD --&gt; D(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    K(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Compare Movies\"):::PromptTask\n    subgraph movie 1 [\" \"]\n    B --&gt; BE([E.T.]):::Result\n    BE --&gt; E(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    E --&gt; HK([\"A troubled child summons \\nthe courage to help \\na friendly alien ...\"]):::Result\n    end\n\n    subgraph movie 2 [\" \"]\n    C --&gt; CF([Wizard of Oz]):::Result\n    CF --&gt; F(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    F --&gt; IK([\"A classic film from \\n1939 in which young \\nDorothy Gale and her\\ndog Toto ...\"]):::Result\n\n    end\n    subgraph movie 3 [\" \"]\n    D --&gt; CG([Big]):::Result\n    CG --&gt; G(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    G --&gt; JK([\"After wishing to be\\nmade big, a teenage boy\\nwakes to find ...\"]):::Result\n    end\n    HK ---&gt; K\n    IK ---&gt; K\n    JK ---&gt; K\n\n    K --&gt; L([\"\\nAll three movies:\n    &lt;i&gt;E.T. the Extra-Terrestrial&lt;/i&gt;, &lt;i&gt;The Wizard of Oz&lt;/i&gt;, and &lt;i&gt;Big&lt;/i&gt;, \n            share a common theme of fantastical journeys and adventures.    \n            They all involve characters who are thrust into extraordinary \n            circumstances that are far removed from their normal lives.\\n\\n\"]):::Result\n\n    classDef PromptTask stroke:#A00\n    classDef ToolkitTask stroke:#f06090\n    classDef Result fill:#5552,stroke:#555\n</code></pre>"},{"location":"courses/compare-movies-workflow/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at intermediate level Python developers who are interested in learning about Griptape Workflows and how to handle parent/child task relationships. </p>"},{"location":"courses/compare-movies-workflow/#prerequisites","title":"Prerequisites","text":"<p>Before beginning this course, you will need:</p> <ul> <li>An OpenAI API Key (available here: https://beta.openai.com/account/api-keys)</li> <li>Python3.9+ installed on your machine</li> <li>An IDE (such as Visual Studio Code or PyCharm) to write and manage your code</li> </ul> <p>If you don't have those items available, it's highly recommended you go through the Griptape Setup - Visual Studio Code course to set up your environment.</p>"},{"location":"courses/compare-movies-workflow/#course-outline","title":"Course Outline","text":"<p>The course will cover:</p> <ul> <li>Creating your first workflow</li> <li>Making it scalable</li> <li>Handling inputs with Jinja2 templates</li> <li>Using the WebScraper tool</li> <li>Understanding Workflow Outputs</li> </ul>"},{"location":"courses/compare-movies-workflow/#useful-resources","title":"Useful Resources","text":"<p>These resources will provide additional information and context throughout the course:</p> <ul> <li>Griptape Documentation</li> <li>Visual Studio Code</li> <li>Jinja2 Documentation</li> </ul>"},{"location":"courses/compare-movies-workflow/#next-steps","title":"Next Steps","text":"<p>Get yourself all setup and ready by moving on to Setup.</p>"},{"location":"courses/compare-movies-workflow/01_setup/","title":"Setup","text":"<p>As with any project, the first step is setting up your environment. Let's get started by ensuring you have a project structure ready to work with.</p>"},{"location":"courses/compare-movies-workflow/01_setup/#prerequisites","title":"Prerequisites","text":"<p>Important</p> <p>Since this is an intermediate level course, please ensure you've gone through the Griptape Setup - Visual Studio Code course to set up your environment. We will be starting from the code at that point.</p> <ol> <li> <p>Code Editor: We recommend using Visual Studio Code for this course, due to its handy features and Python support. However, if you have another favorite IDE or text editor, feel free to use that! </p> </li> <li> <p>Python3.9+: Griptape requires Python 3.11wor and above.</p> </li> <li> <p>Python Environment Manager (for VS Code users): This extension is not a hard requirement, but it does make managing your Python environments a lot easier. </p> </li> <li> <p>OpenAI API Key: Our chatbot will be powered by gpt-4, which requires an API key from OpenAI. You can get your key from OpenAI's website.</p> </li> </ol> <p>Got everything installed? Awesome! Now, let's get started setting up our project.</p>"},{"location":"courses/compare-movies-workflow/01_setup/#create-a-project","title":"Create a Project","text":"<p>Following the instructions in Griptape Setup - Visual Studio Code  please:</p> <ol> <li>Create your project folder. Example: <code>griptape-compare-movies-workflow</code></li> <li>Set up your virtual environment</li> <li>Ensure you <code>pip install griptape python-dotenv</code></li> <li>Create a <code>.env</code> file with your <code>OPENAI_API_KEY</code></li> <li>Create your <code>app.py</code> file with the following code:</li> </ol> app.py<pre><code>from dotenv import load_dotenv\n\nload_dotenv() # Load your environment\n</code></pre>"},{"location":"courses/compare-movies-workflow/01_setup/#next-steps","title":"Next Steps","text":"<p>And there we have it, environment is all set up! In the next section Concepts, we'll dive deeper into understanding the concepts of Pipelines, Workflows, and Tasks.</p>"},{"location":"courses/compare-movies-workflow/02_concepts/","title":"Main Concepts","text":""},{"location":"courses/compare-movies-workflow/02_concepts/#understanding-workflows-and-pipelines","title":"Understanding Workflows and Pipelines","text":"<p>Frequently when creating applications you will want to execute a series of steps in a very specific order. Workflows and Pipelines are both structures that allow us to do that. They have many of the same features as Agents, but are more directable. Whereas Agents can be given behaviors and tools and will use them when prompted appropriately, Pipelines and Workflows utilize hieararchies of tasks in very specific ways.</p>"},{"location":"courses/compare-movies-workflow/02_concepts/#pipelines","title":"Pipelines","text":"<p>Pipelines are always a sequential series of steps - one task after another until it is finished. </p> <p>In this course we're going to be taking some rough descriptions of movies and getting their actual names, then getting the summaries from the web and comparing them. Doing this as a Pipeline might look something like:</p> <ol> <li>Get movie descriptions</li> <li>Get the actual name of the movie</li> <li>Look up the summary </li> </ol> <p>The flow of tasks would be:</p> <pre><code>graph LR\n    A(Movie Description) --&gt; C(Get Name ) --&gt; D(Get Summary)</code></pre> <p>This works great for our simple task, but the point of this course is to compare multiple movies. If we use a standard linear pipeline, it would mean:</p> <pre><code>graph LR\n    A(Movie Descriptions) --&gt; B(Get Name 1) --&gt; D(Get Summary 1) --&gt; E(Get Name 2) \n    E --&gt; F(Get Summary 2) --&gt; G(\"Get Name &lt;i&gt;n&lt;/i&gt;\" ):::dash --&gt; H(\"Get Summary &lt;i&gt;n&lt;/i&gt;\"):::dash \n    H --&gt; I(Compare)\n\n    classDef dash stroke-dasharray: 5 5\n</code></pre> <p>As you can tell, this could get quite unweildy. In addition, it doesn't make much sense for getting the name of the 4th movie to have to wait until the summary of the 3rd movie is figured out, as they're not really dependent on each other.</p> <p>Workflows are perfect for this sort of situation. They allow you to parallelize tasks that aren't dependent. Let's see how something like this might look.</p>"},{"location":"courses/compare-movies-workflow/02_concepts/#workflows","title":"Workflows","text":"<p>Workflows allow for complex interactions, resembling tree branches.</p> <p>Workflows are non-sequential and individual tasks can depend on multiple input tasks. This allows you to create a single task that waits for all other tasks to complete before it can begin.</p> <p>This is what a Workflow might look like for doing what we mentiond above. </p> <p>Note</p> <p>The graph is drawn top to bottom for this example because it's easier to understand the flow of data, but it can be drawn in either direction.</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(Get Name 1) --&gt; D(Get Summary 1) --&gt; I(Compare)\n    A --&gt; E(Get Name 2) --&gt; F(Get Summary 2) --&gt; I\n    A --&gt; G(\"Get Name &lt;i&gt;n&lt;/i&gt;\" ):::dash\n    G --&gt; H(\"Get Summary &lt;i&gt;n&lt;/i&gt;\"):::dash \n    H --&gt; I\n    classDef dash stroke-dasharray: 5 5\n</code></pre> <p>Notice how the movies can be evaluated in parallel, but the Compare task will wait until all it's parent tasks are completed. </p>"},{"location":"courses/compare-movies-workflow/02_concepts/#tasks","title":"Tasks","text":"<p>Before we dive in and start setting up our own workflow, it's important to review the concepts of Tasks. With Griptape, there are many types of tasks you'll be working with, including:</p> Task Type Description Example PromptTask General purpose prompting to the LLM. <code>PromptTask(\"Tell me a story about skateboards\")</code> ToolkitTask Uses Griptape Tools to complete a task with Chain of Thought (CoT) reasoning. <code>ToolkitTask(\"Summarize griptape.ai\", tools=[WebScraper()])</code> TookTask Similar to ToolkitTask, but only uses a single tool and no CoT. <code>ToolTask(\"Give me the answer for 52-10\", tool=Calculator())</code> Extraction Tasks Various tasks associated with extracting information from text. See examples in the documentation. TextSummaryTask Summarizes text very efficiently <code>TextSummaryTask(\"Imagine this is a massive amount of text.\")</code> TextQueryTask Can be used to query large bodies of text, for example a vector database. See examples in the documentation <p>In this course we will be focusing mostly on Prompt Tasks and Toolkit Tasks. Both of these task types are used to work with the LLM. They both take an input as a prompt, can take arguments, use specific drivers, and have parent/child relationships. The main difference between them is that ToolkitTasks can also use tools like Calculator(), FileBrowser(), and more. View all the tools available with Griptape here.</p> <pre><code># Example PromptTask to get a movie name\n#\nmovie_task = PromptTask(\n    \"What is this movie: {{ descr }}\",\n    context = {                        \n        \"descr\": \"princess and farmhand named Wesley\" \n    },\n    id=\"movie_id\"                      # task id can be referenced by other tasks\n)\n\n# This ToolkitTask works with the output of the previous task, and can use tools.\n#\ndescribe_task = ToolkitTask(\n    \"Get the description of this movie: {{ parent_outputs['movie_id'] }}\",       \n    tools = [                          \n        WebScraper()\n    ],\n    id='describe_id')\n</code></pre> <p>I have found that the best way to really understand how PromptTasks and ToolkitTasks work is to use them in context. So let's move on to the next section where we'll create our First Workflow, and get an understanding of the basics of how parent/child relationships can work.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/","title":"First Workflow","text":""},{"location":"courses/compare-movies-workflow/03_first_workflow/#overview","title":"Overview","text":"<p>In this section we're going to create the first workflow in our Movie Comparison application. By the end of this section you will have a workflow that lets you create a cursory comparison between two movies.</p> <p>For example, if you pass it these two descriptions:</p> <ul> <li>\"A boy discovers an alien in his back yard\"</li> <li>\"A shark attacks a beach\"</li> </ul> <p>It will come back with:</p> <p>Result</p> <p>Both E.T. the Extra-Terrestrial and Jaws are directed by Steven Spielberg.   They are also both iconic films that have had a significant impact on popular culture.</p> <p>The hierarchy we will create looks like the following:</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        B(Describe Workflow):::main --&gt; C(Movie 1) --&gt; E(Compare Task):::main\n        B --&gt; D(Movie 2) --&gt; E\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre> <p>As you can see, there is a <code>Workflow</code> Structure, and four tasks that will be created. The Start and End tasks (Describe Workflow and Compare Task), and two siblings (Movie 1 and Movie 2). Compare Task will be dependent on them to complete before it can execute.</p> <p>Tip</p> <p>Workflows must always have a Start and End task.</p> <p>To generate this structure, we will first create our Start and End tasks, and then insert the movie tasks. This will guarantee that our tasks exist in the workflow exactly where we want them. <pre><code>flowchart TB \n    subgraph Step 2 [\"Insert\"]\n        direction TB\n        C(Describe Workflow):::main --&gt; D(Movie 1) --&gt; F(Compare Task):::main\n        C --&gt; E(Movie 2) --&gt; F\n    end\n\n    subgraph Step 1 [\"Start &amp; End\"]\n        direction TB\n        A(Describe Workflow):::main --&gt; B(Compare Task):::main\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre></p> <p>Let's get started.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#importing-required-modules","title":"Importing Required Modules","text":"<p>Before starting, we need to import the necessary modules. Open the <code>app.py</code> file you created in the setup section and import the two Griptape classes you'll need: <code>Workflow</code> and <code>PromptTask</code>:</p> <pre><code>from dotenv import load_dotenv\n\n# Griptape\nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\n\nload_dotenv() # Load your environment\n</code></pre> <p>Note</p> <p>You might recall that <code>Agent</code> was also imported through <code>griptape.structures</code>. That's because <code>Agent</code>, <code>Workflow</code>, and <code>Pipeline</code> are all Griptape's ways of working with LLMs. </p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#create-workflow-structure","title":"Create Workflow Structure","text":""},{"location":"courses/compare-movies-workflow/03_first_workflow/#initialize-the-workflow","title":"Initialize the Workflow","text":"<p>Now, let's create the foundation for our Workflow. After the line <code>load_dotenv()</code>, create an instance of the Workflow class:</p> <pre><code># ... truncated for brevity\nload_dotenv() # Load your environment\n\n# Create the workflow object\nworkflow = Workflow()\n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#create-a-start-task","title":"Create a Start task","text":"<p>First, we'll create our \"start\" task. This will be a simple <code>PromptTask</code> that lets the LLM know what we're going to do. </p> <p>After the <code>workflow</code> line, add: <pre><code># Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\n</code></pre></p> <p>There are two things that are important to point out in this task creation.</p> <ol> <li>Notice that we're using a <code>PromptTask</code>. That's because we don't need to use any tools for this particular task, we only want to use the LLM.</li> <li>We have given the task an <code>id</code>. This is so we can reference it later in the script. If you don't pass this value, the task will be given a random string as the id.</li> </ol> <p>Important</p> <p>Every task in a workflow must have a unique id. If two tasks have the same id, the workflow will fail.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#add-task-to-the-workflow","title":"Add Task to the Workflow","text":"<p>You have created the task, but it's not yet part of the workflow. In order to do that, we'll need to use the <code>add_task</code> method.</p> <p>After the PromptTask line, add:</p> <pre><code># Add tasks to workflow\nworkflow.add_task(start_task)\n</code></pre> <p>At this point, your workflow flow graph looks like:</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        B(PromptTask: START):::main\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre> <p>However if you execute your script, nothing will happen. That's because you need to tell the workflow graph to run.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#run-the-workflow","title":"Run the Workflow","text":"<p>To run a workflow, you simply need to call the method <code>run</code>:</p> <pre><code># Run the workflow\nworkflow.run()\n</code></pre> <p>Here's the result. Notice in the logs you can see the Task inputs and outputs: <pre><code>[11/15/23 13:05:49] INFO     PromptTask START                                                                                   \n                             Input: I will provide you a list of movies to compare.                                             \n[11/15/23 13:05:52] INFO     PromptTask START                                                                                   \n                             Output: Sure, please provide the list of movies you want me to compare.                            \n</code></pre></p> <p>As you can see, the LLM is ready to take a list of movies.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#add-the-end-task","title":"Add the end task","text":"<p>The next task we'll add will be the last task. This is a good place to create a task that summarizes what has been done, and then add it to the end of the workflow using the same <code>add_task</code> method.</p> <pre><code># Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\nend_task = PromptTask(\"How are the movies the same?\", id=\"END\")\n\n# Add tasks to workflow\nworkflow.add_task(start_task)\nworkflow.add_task(end_task)\n</code></pre> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        B(PromptTask: START):::main --&gt; C(PromptTask: END):::main\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre> <p>Tip</p> <p>This process has changed from versions of Griptape prior to v0.20.</p> <p>In previous versions, the <code>add_task</code> method would add tasks as siblings of the parent task. With versions greater than 0.20, they add them one after another. To add tasks as sibblings you will be inserting tasks.</p> <pre><code># Add tasks to workflow\nworkflow.add_task(start_task)\nworkflow.add_task(end_task)\n</code></pre> After Griptape 0.2.0Before Griptape 0.2.0 <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        B(PromptTask: START):::main --&gt; C(PromptTask: END):::main\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        B(PromptTask: START):::main\n        C(PromptTask: END):::main\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#add-tasks-into-workflow","title":"Add Tasks into Workflow","text":""},{"location":"courses/compare-movies-workflow/03_first_workflow/#create-the-first-movie-prompt-task","title":"Create the first Movie Prompt task","text":"<p>Now it's time to create the first task asking the LLM to identify a movie. This will be a <code>PromptTask</code>.</p> <p>In your code, after the <code>end_task</code>, add:</p> <pre><code># Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\nend_task = PromptTask(\"How are the movies the same?\", id=\"END\")\n\n# Create movie tasks\nmovie_1_task = PromptTask(\"What movie is this: boy finds alien in backyard.\", id=\"movie_1\")\n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#insert-the-task-into-the-workflow","title":"Insert the Task into the Workflow","text":"<p>You have created the task, but it's not yet part of the workflow. In order to do that, we'll need to use the <code>insert_tasks</code> method.</p> <p>The <code>insert_tasks</code> method takes a couple of arguments. It looks like this: <pre><code>workflow.insert_tasks(task_a, [task_c, task_d], task_b)\nworkflow.insert_tasks(task_c, [task_e, task_f], task_b)\n</code></pre></p> <p>Notice the second argument is a <code>list</code> of tasks. This method will take two tasks that already have a parent/child relationship, and insert whatever tasks are listed in that second argument between them. </p> <p>The graph above would look something like:</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(task_a)\n        B(task_b)\n        C(task_c)\n        D(task_d)\n        E(task_e)\n        F(task_f)\n        A --&gt; B --&gt; D\n        A --&gt; C --&gt; E --&gt; D\n        C --&gt; F --&gt; D\n    end\n</code></pre> <p>We'll see this in more detail shortly, but for now let's just add the single task.</p> <p>In your script, after the <code>add_task</code> lines, add:</p> <pre><code># Add tasks to workflow\nworkflow.insert_tasks(start_task, [movie_1_task], end_task)\n</code></pre> <p>At this point, your workflow flow graph looks like:     <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(PromptTask: START):::main\n        B(PromptTask: movie_1_task)\n        C(PromptTask: END):::main\n        A --&gt; B --&gt; C\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff</code></pre></p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#run-the-workflow_1","title":"Run the Workflow","text":"<p>Run the script to see the output.</p> <p>Here's the result. Notice the tasks being executed, and the summary where it tries to compare the results:</p> <pre><code>[11/15/23 14:10:59] INFO     PromptTask START                                                                                   \n                             Input: I will provide you a list of movies to compare.                                             \n[11/15/23 14:11:00] INFO     PromptTask START                                                                                   \n                             Output: Sure, please provide the list of movies you want me to compare.                            \n                    INFO     PromptTask movie_1                                                                                 \n                             Input: What movie is this: boy finds alien in backyard.                                            \n[11/15/23 14:11:02] INFO     PromptTask movie_1                                                                                 \n                             Output: The movie you are referring to is likely \"E.T. the Extra-Terrestrial\" directed by Steven    \n                             Spielberg.                                                                                         \n                    INFO     PromptTask END                                                                                     \n                             Input: How are the movies the same?                                                                \n[11/15/23 14:11:06] INFO     PromptTask END                                                                                     \n                             Output: As an AI, I need specific movies to compare in order to provide similarities. Please       \n                             provide the names of the movies you want to compare.                                               \n</code></pre> <p>The LLM is unable to compare the results for two reasons - first, we only passed a single movie. Second, we didn't pass the information about the movie back to the LLM so it doesn't know what we were talking about. We'll take care of these one at a time.</p> <p>First, we'll add a second movie.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#second-movie-task","title":"Second Movie Task","text":"<p>Just below the first movie PromptTask, add a second one with another description.</p> <pre><code># ...\n\n# Create tasks\nmovie_1_task = PromptTask(\"What movie is this: boy finds alien in backyard.\", id=\"movie_1\")\nmovie_2_task = PromptTask(\"What movie is this?: a shark attacks a beach.\", id=\"movie_2\")\n\n# ...\n</code></pre> <p>Important</p> <p>Don't forget to add the id to the second task and make sure it's unique from the first task.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#add-second-task-to-workflow","title":"Add Second Task to Workflow","text":"<p>Just like before, we need to insert <code>movie_2_task</code> to <code>workflow</code> with the <code>insert_tasks</code> method. Modify the previous insert_tasks line to include both movie tasks.</p> <pre><code># ...\n\n# Add tasks to workflow\nworkflow.insert_tasks(start_task, [movie_1_task, movie_2_task], end_task)\n\n# ...\n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#test","title":"Test","text":"<p>Go ahead and run the code and notice that the two movie tasks executed in parallel:</p> <pre><code># ... truncated for brevity\n\n[11/15/23 14:14:32] INFO     PromptTask START                                                                                   \n                             Input: I will provide you a list of movies to compare.                                             \n[11/15/23 14:14:34] INFO     PromptTask START                                                                                   \n                             Output: Sure, I am ready to help you compare the movies. Please provide the list.                   \n                    INFO     PromptTask movie_2                                                                                 \n                             Input: What movie is this?: a shark attacks a beach.                                               \n                    INFO     PromptTask movie_1                                                                                 \n                             Input: What movie is this: boy finds alien in backyard.                                            \n[11/15/23 14:14:38] INFO     PromptTask movie_2                                                                                 \n                             Output: This could refer to several movies as shark attacks are a common theme in many films.      \n                             However, the most iconic one is \"Jaws\" directed by Steven Spielberg.                               \n                    INFO     PromptTask movie_1                                                                                 \n                             Output: This could refer to several movies, but the most famous one is probably \"E.T. the          \n                             Extra-Terrestrial\" directed by Steven Spielberg.                                                   \n                    INFO     PromptTask END                                                                                     \n                             Input: How are the movies the same?                                                                \n[11/15/23 14:14:41] INFO     PromptTask END                                                                                     \n                             Output: As an AI, I need more specific details to provide a comparison. Please provide the names of\n                             the movies you want to compare.                                                        \n</code></pre> <p>Hmm. It doesn't look like the <code>compare</code> task knows what we're talking about. The workflow evaluated both we sent it, we can see that in the logs above, but the compare task has no knowledge of them. </p> <p>That's because we need to pass the results of the previous task to the current task. This is a very important feature, as it allows us to be very specific about what data is sent to the LLM.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#pass-the-data","title":"Pass the Data","text":"<p>In order to send the data to the PromptTask, we need to somehow feed the result of the previous task's execution to the prompt.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#jinja2","title":"Jinja2","text":"<p>Griptape uses the Jinja2 template engine, which allows you to insert data into the prompt. There's a lot of power available with Jinja templates, but in this course we'll keep our focus rather small.</p> <p>Jinja templates access variables using the <code>{{ }}</code> syntax. Tasks have a property <code>parent_outputs</code> that tell us what objects are coming into the node.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#update-the-prompt","title":"Update the Prompt","text":"<p>In order to update the prompt, we want to tell it what tasks to be looking at. If you check your code, you can see that we used the <code>id</code> property earlier when we were creating the tasks:</p> <pre><code>movie_1_task = PromptTask(\"What movie is this?: A boy discovers an alien in his back yard\", id=\"movie_1\")\nmovie_2_task = PromptTask(\"What movie is this?: a shark attacks a beach.\", id=\"movie_2\")\n</code></pre> <p>So <code>movie_1</code> and <code>movie_2</code> are the two ids we can use in our Jinja template. They can be specified like this: <code>{{ parent_outputs['movie_1'] }}</code> and <code>{{ parent_outputs['movie_2'] }}</code></p> <p>Update the <code>END</code> task to specify the particular ids of the parent_outputs. Note - I'm using <code>\"\"\"</code> in order to allow us to use multiple lines for the PromptTask string.</p> <pre><code>end_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{ parent_outputs['movie_1'] }}\n    {{ parent_outputs['movie_2'] }}\n    \"\"\",\n    id=\"compare\")\n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#test_1","title":"Test","text":"<p>When you run the script now, you should see a much better Input:</p> <pre><code>[11/15/23 14:19:24] INFO     PromptTask END        \n                             Input:                                                                                             \n                                 How are these movies the same:                                                                 \n                                 This could be referring to \"E.T. the Extra-Terrestrial\" directed by Steven Spielberg.          \n                                 This could be referring to several movies as shark attacks are a common theme in films.        \n                             However, the most iconic movie featuring a shark attack on a beach is \"Jaws\" directed by Steven    \n                             Spielberg.                                                                                         \n[11/15/23 14:19:26] INFO     PromptTask END\n                             Output: These movies are the same in that they are both directed by Steven Spielberg.\n</code></pre> <p>The code works but it's if you look closely at the <code>END</code> task input, you'll see that it's using the full string of the response from the prompts:</p> <pre><code>How are these movies the same:                                                    \nThat sounds like the movie \"E.T. the Extra-Terrestrial\".                          \nThat could be several movies, but the most famous one is probably \"Jaws\". \n</code></pre> <p>What we really want is just the name of the movie, not any commentary. We can fix that by adjusting the prompt in the initial query.</p>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#fix-the-prompt","title":"Fix the Prompt","text":"<p>Change the movie PromptTasks so we ask for just the name: <pre><code>movie_1_task = PromptTask(\n    \"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\", \n    id=\"movie_1\")\nmovie_2_task = PromptTask(\n    \"What movie is this? Return only the movie name: a shark attacks a beach.\", \n    id=\"movie_2\")\n</code></pre></p> <p>After running the response input task should be much cleaner:</p> <pre><code>How are these movies the same: \nE.T. the Extra-Terrestrial                  \nJaws   \n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#code-review","title":"Code Review","text":"<p>We covered quite a lot of ground creating your first workflow. Double-check your script and make sure you've got it working as expected:</p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape\nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\n\nload_dotenv() \n\n# Create the workflow object\nworkflow = Workflow()\n\n# Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\nend_task = PromptTask(\n    \"\"\"\n    How are these movies the same: \n    {{ parent_outputs['movie_1'] }}\n    {{ parent_outputs['movie_2'] }}\n    \"\"\",\n    id=\"END\",\n)\n# Create movie tasks\nmovie_1_task = PromptTask(\n    \"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\",\n    id=\"movie_1\",\n)\nmovie_2_task = PromptTask(\n    \"What movie is this? Return only the movie name: a shark attacks a beach.\",\n    id=\"movie_2\",\n)\n\n# Add tasks to workflow\nworkflow.add_task(start_task)\nworkflow.add_task(end_task)\n\n# Add tasks to workflow\nworkflow.insert_tasks(start_task, [movie_1_task, movie_2_task], end_task)\n\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"courses/compare-movies-workflow/03_first_workflow/#next-step","title":"Next Step","text":"<p>In the next section we are going to make our script a bit more flexible by making it possible to compare as many movie descriptions as we want. Check out Adding Flexibility when you're ready to continue.</p>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/","title":"Adding Flexibility","text":""},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#overview","title":"Overview","text":"<p>In the previous section you created your first workflow. It works well for two movie descriptions, however if you want to expand to more movies it could be a bit difficult for a few reasons.</p> <ol> <li>We're creating the tasks and adding them to the workflow one at a time.</li> <li>In the comparison task we target the specific ids of the movie tasks.</li> <li>We're repeating our prompt \"What movie is this? Return only the name\" over and over again.</li> </ol> <p>So in this section, we'll make our application more flexible by defining a list of movie descriptions, and then iterate through that list to create PromptTasks and add them to the workflow.</p>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#movie-description-list","title":"Movie Description List","text":"<p>Locate the section of your code where you create the list of movie tasks: <pre><code># ...\n\n# Create movie tasks\nmovie_1_task = PromptTask(\n    \"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\", \n    id=\"movie_1\")\nmovie_2_task = PromptTask(\n    \"What movie is this? Return only the movie name: a shark attacks a beach.\", \n    id=\"movie_2\")\n\n# ...\n</code></pre></p> <p>We're going to replace this entire section with a <code>descriptions</code> list instead. This will be a list of python dictionaries with an \"id\" and a \"descriptoin\".</p> <p>It should look something like: <pre><code># Create a list of movie descriptions\nmovie_descriptions = [\n    \"A boy discovers an alien in his back yard\",\n    \"A shark attacks a beach\"\n]\n</code></pre></p>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#iterate-through-list","title":"Iterate through list","text":"<p>Now to create our PromptTasks, we'll iterate through the list of movie_descriptions.</p> <p>Locate the <code>insert_task</code> code where we inserted the tasks into the workflow:</p> <pre><code># Add tasks to workflow\nworkflow.insert_tasks(start_task, [movie_1_task, movie_2_task], end_task)\n</code></pre> <p>We will replace this with a for loop where we create the PromptTask then insert it.</p> <pre><code># ...\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }}\",\n        context = {\n            \"description\": description\n        })\n\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n\n# ...\n</code></pre> <p>As you can see, we:</p> <ol> <li>Iterate through each <code>description</code> in the list of <code>movie_descriptions</code>. </li> <li>Create a <code>PromptTask</code> and pass that <code>description</code> to the <code>context</code> into a variable also called <code>description</code>.</li> <li>Use that variable via Jinja2 templates in the prompt itself: <code>{{ description }}</code>.</li> <li>Once the <code>PromptTask</code> is created, we insert it to the workflow using the <code>insert_tasks</code> method.</li> </ol>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#update-end-task","title":"Update End Task","text":"<p>There's one final step we need to take before we can run this. In our <code>end_task</code>, we're specifically identifying <code>movie_1</code> and <code>movie_2</code> in the prompt:</p> <pre><code>end_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{parent_outputs['movie_1']}}\n    {{parent_outputs['movie_2']}}\n    \"\"\",\n    id=\"compare\")\n</code></pre> <p>This will no longer work because we are not defining the ids when we create the PromptTask - we just let it come up with it's own unique identifiers. Also, we don't know exactly how many movies we might be comparing, so it doesn't make much sense to define and add each one individually.</p> <p>Luckily, intead of specifically specifying the items via id, we can just say \"hey - give me all the input items\" using <code>{{ parent_outputs }}</code>. This will return the entire <code>python dictionary</code> of items that are input to the task.</p> <p>Replace the two lines:</p> <pre><code>    {{parent_outputs['movie_1']}}\n    {{parent_outputs['movie_2']}}   \n</code></pre> <p>with:</p> <pre><code>    {{ parent_outputs }}\n</code></pre> <p>The <code>compare_task</code> section should now look like:</p> <pre><code>compare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{ parent_outputs }}\n    \"\"\",\n    id=\"compare\")\n</code></pre>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#test","title":"Test","text":"<p>Let's run the code and see what we get.</p> <pre><code>[08/13/23 10:08:28] INFO     Task compare                                                                                                                     \n                             Input:                                                               \n                                 How are these movies the same:{'74bd46cfd17a4ccaa92308029b508751': 'E.T. the                  \n                             Extra-Terrestrial', '90ed4594b9af4ad9ac2fe45cd53c7889': 'Jaws'}                                                             \n\n[08/13/23 10:08:31] INFO     Task compare                                                                                                                     \n                             Output: Both 'E.T. the Extra-Terrestrial' and 'Jaws' are iconic movies directed by Steven Spielberg. They are known for their    \n                             memorable storylines and have had a significant impact on popular culture.                                                       \n</code></pre> <p>We get the proper output for our task - it compares ET and Jaws as we expect. But notice the input.</p> <pre><code>Input:                                                                                                                           \n    How are these movies the same:                                                                                               \n    {'74bd46cfd17a4ccaa92308029b508751': 'E.T. the Extra-Terrestrial', '90ed4594b9af4ad9ac2fe45cd53c7889': 'Jaws'}                                                             \n</code></pre> <p>Instead of passing just the names of the movies, it's passing the entire dictionary of items. It works but it's extra data. Don't worry, there's a way to clean this up using Jinja2 for loops.</p>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#iterate-through-item-values","title":"Iterate through item values","text":"<p>Jinja2 has a for loop structure that looks like: <pre><code>{% for value in list.values() %}\n{{ value }}\n{% endfor %}\n</code></pre></p> <p>We can use this inside our PromptTask to iterate through the items and just output the names.</p> <p>Replace the <code>{{ parent_outputs }}</code> section of the <code>PromptTask</code> with a for loop that will get the key/value pairs (id, movie name) and output just the value.</p> <p>Tip</p> <p>For Jinja2 to iterate through the values of dict, you need to use <code>parent_outputs.values()</code>.</p> <pre><code># ... \n\nend_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for value in parent_outputs.values() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\n    id=\"END\")\n\n# ...\n</code></pre>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#test_1","title":"Test","text":"<p>Run the script again and let's see how it looks.</p> <pre><code>INFO     Task END\n            Input:\n                How are these movies the same:\n                E.T. the Extra-Terrestrial\n                Jaws\n</code></pre> <p>Much better. Go ahead and add a third movie to the structure and run it again. Everything should work as expected. I added \"A princess and a man named Wesley\" (from the movie The Princess Bride) and got the following result:</p> <p>Result</p> <p>All three movies, E.T. the Extra-Terrestrial, Jaws, and The Princess Bride, are iconic films   from the late 20th century. They all fall under the genre of adventure and have elements of fantasy.   Additionally, they have been highly influential in popular culture and have received critical acclaim.  </p>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#code-review","title":"Code Review","text":"<p>There was not as much work in this section, but we did cover some important concepts. </p> <ul> <li>We made our code more flexible by using a list of descriptions to create PromptTasks instead of creating them one at a time.</li> <li>We used a Jinja2 template for loop to iterate through each incoming item.</li> </ul> <p>Review your code with the current state to make sure everything is working as expected.</p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\n\n# Load environment variables\nload_dotenv()\n\n# Create a Workflow\nworkflow = Workflow()\n\n# Create a list of movie descriptions\nmovie_descriptions = [\n    \"A boy discovers an alien in his back yard\",\n    \"A shark attacks a beach\",\n    \"A princess and a man named Wesley\"\n]\n\nend_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for value in parent_outputs.values()%}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\n    id=\"END\")\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }} \",\n        context={\"description\": description})\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"courses/compare-movies-workflow/04_adding_flexibility/#next-step","title":"Next Step","text":"<p>Our code works, but the descriptions of the movies aren't as detailed as they could be. It would be better if we could search the web for detailed information about the movies, and use those results for a more comprehensive comparison.</p> <p>In the next section we will add to our workflow by adding a ToolkitTask that uses the <code>WebScraper</code> tool to get more detailed information. Jump to Using Tools when you're ready to continue.</p>"},{"location":"courses/compare-movies-workflow/05_using_tools/","title":"Using Tools","text":""},{"location":"courses/compare-movies-workflow/05_using_tools/#overview","title":"Overview","text":"<p>We added flexibility in the last section to allow our application to handle an undefined number of movies. The workflow hierarchy looks like:</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        I(\"PromptTask: End\"):::main\n        A --&gt; B --&gt; I\n        A --&gt; G --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n</code></pre> <p>However, the comparisons coming back don't feel very deep and meaningful. We'd like to get a more detailed analysis of the film comparisons by getting a better summary of each film from the web. </p> <p>To do that we'll use add a <code>ToolkitTask</code> to our workflow for each movie. This will result in the following chart.</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        C(\"ToolkitTask: Summary Task 1\"):::tool\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\" ):::tool-dash\n        I(\"PromptTask: End\"):::main\n        A --&gt; B --&gt; C --&gt; I\n        A --&gt; G --&gt; H --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#import","title":"Import","text":"<p>The three new classes we'll need to import are <code>ToolkitTask</code>, <code>TaskMemoryClient</code>, and <code>WebScraper</code>.</p> <p>ToolkitTask is a task just like **PromptTask, except it allows you to specify the use of Tools. </p> <p>TaskMemoryClient is a way to handle data used in a task. It allows you to control where information is sent, keeping it off-prompt and away from the LLM when required. Note: in this course we'll be setting <code>off-prompt</code> to <code>False</code>, allowing the LLM to see the task results. In future courses we'll discuss ways to keep the data private.</p> <p>WebScraper is a specific tool that allows the LLM to scrape the web for information. We'll use this to get a better summary of each movie.</p> <p>In the top of your application, modify the import statements to include ToolkitTask, TaskMemoryClient, and WebScraper.</p> <pre><code>from dotenv import load_dotenv\n\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper, TaskMemoryClient\n</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#summary-toolkittask","title":"Summary ToolkitTask","text":"<p>Now we'll add the <code>ToolkitTask</code> to the section of our code where we iterate through each movie description.</p> <p>We will call it the same way we do PromptTask, except the ToolkitTask takes a list of tools. In this example, you can see that it's using two tools - WebScraper and TaskMemoryClient</p> <pre><code>summary_task = ToolkitTask(\n    \"Use metacritic to get a summary of this movie: {{ }}\", \n    tools = [WebScraper(), TaskMemoryClient(off_prompt=False)],\n    )\n</code></pre> <p>When we call the <code>ToolkitTask</code> we'll need to pass the output of the previous task (the movie_task) to it. There are a few options we can use to do this, depending on the needs of our application.</p>"},{"location":"courses/compare-movies-workflow/05_using_tools/#option-1-all-incoming-items","title":"Option 1: All Incoming Items","text":"<p>If you recall from the previous section, using the Jinja Template <code>{{ parent_outputs }}</code> will give you a list of dicts from all incoming tasks. </p> <p>Example:  <pre><code>    \"Use metacritic to get a summary of this movie: {{ parent_outputs }}\"\n</code></pre></p> <p>In this case, the return would look something like: <pre><code>Input: Get a summary of the movie: {'4aca083cdc5a4b76bb7ee7b91f0ec358': 'The Princess Bride'}                                                                       \n</code></pre></p> <p>While this works, it does provide some extraneous information. We know that there is only one item coming in - so it's not necessary to use this list of dicts. Jinja2 provides filters to reduce this.</p>"},{"location":"courses/compare-movies-workflow/05_using_tools/#option-2-filter-for-one-item","title":"Option 2: Filter for One Item","text":"<p>Jinja2 allows you to use filters to return specific information. The format with Jinja2 is to use a <code>|</code> notation to add a filter.</p> <p>For example, we can use <code>{{ parent_outputs.values() | list }}</code>to return a <code>list</code> of values, and then also get just the <code>last</code> item in the list. That would look like: <code>{{ parent_outputs.values()|list|last }}</code>:</p> <pre><code>    \"Use metacritic to get a summary of this movie: {{ parent_outputs.values()|list|last }}\"\n</code></pre> <p>And the result would be:</p> <pre><code>Input: Get a summary of the movie: The Princess Bride                      \n</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#compare-all-options","title":"Compare all options","text":"<p>As you can see, there are multiple ways to get the result we're looking for. Review the options below to see how they are unique. </p> All ItemsFilter For One <pre><code># code\nsummary_task = ToolkitTask(\n    \"Use metacritic to get a summary of this movie: {{ parent_outputs }}\",\n    tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n    )\n\n# result\n{'4aca083cdc5a4b76bb7ee7b91f0ec358': 'The Princess Bride'} \n</code></pre> <pre><code># code\nsummary_task = ToolkitTask(\n    \"Use metacritic to get a summary of this movie: {{ parent_outputs.values()|list|last }}\",\n    tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n    )\n\n# result\nThe Princess Bride\n</code></pre> <p>As you can see, Jinja filters are extremely powerful. Let's use the second option as it gives us exactly the result we are looking for: just the name of the movie.</p>"},{"location":"courses/compare-movies-workflow/05_using_tools/#add-toolkittask","title":"Add ToolkitTask","text":"<p>Inside the <code>for description in movie_descriptions:</code> loop, add the <code>summary_task</code> after the <code>movie_task</code> but before the call to the <code>insert_tasks</code> method of <code>workflow.</code></p> <pre><code># ...\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }} \",\n        context={\"description\": description})\n\n    summary_task = ToolkitTask(\n        \"Use metacritic to get a summary of this movie: {{ parent_outputs.values()|list|last  }}\",\n        tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n        )\n\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n\n# ...\n</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#insert-summary-task","title":"Insert Summary Task","text":"<p>At the moment we've created the Summary Task for each movie, but we haven't inserted them into the workflow.</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        C(\"ToolkitTask: Summary Task 1\"):::tool\n        H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\" ):::tool-dash\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        I(\"PromptTask: End\"):::main\n        A --&gt; B --&gt; I\n        A --&gt; G --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5</code></pre> <p>To insert them, we'll need to use another <code>insert_tasks</code> method call, this time telling it to insert between the <code>movie_task</code> and the <code>end_task</code>.</p> <p>Inside the <code>movie_description</code> for loop, after <code>workflow.insert_tasks(start_task, [movie_task], end_task)</code> modify the code to look like:</p> <pre><code># ...\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    # ...\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n    workflow.insert_tasks(movie_task, [summary_task], end_task)\n\n# ...\n</code></pre> <p>Now the workflow graph looks like we expect:</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        C(\"ToolkitTask: Summary Task 1\"):::tool\n        H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\" ):::tool-dash\n        I(\"PromptTask: End\"):::main\n        A --&gt; B --&gt; C --&gt; I\n        A --&gt; G --&gt; H --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#test","title":"Test","text":"<p>Execute the code and let's review the output logs.</p> <p>Note</p> <p>I've removed the timestamps from the logs to make it easier to read. Yours will most likely still have them.</p> <pre><code>INFO Task END                                  \n    Input:                                                                                                  \n        How are these movies the same:                                                                      \n        The movie \"E.T. the Extra-Terrestrial\" is about a troubled child who summons the courage to help a  \n    friendly alien escape from Earth and return to his home planet.                                         \n        \"Jaws\" is a movie about a killer shark that unleashes chaos on a beach community off Cape Cod. It's \n    up to a local sheriff, a marine biologist, and an old seafarer to hunt the beast down. The shark        \n    terrorizes the community, affecting the number of tourists that usually flock to the island. After many \n    attempts, the shark won't go away, leading the sheriff, the marine biologist, and the seafarer to decide\n    to go after the shark and kill it.                                                                      \n        The movie \"The Princess Bride\" is about a bedridden boy's grandfather who reads him the story of a  \n    farmboy-turned-pirate. This farmboy encounters numerous obstacles, enemies, and allies in his quest to  \n    be reunited with his true love. The movie is known for its satirical humor, great dialogue, and fun     \n    adventure scenes. It is whimsical and romantic while also poking fun at the conventions of the fairy    \n    tale genre. \n\nINFO Task END                                  \n    Output: While these three movies, \"E.T. the Extra-Terrestrial\", \"Jaws\", and \"The Princess Bride\", seem  \n    very different in terms of plot and genre, they do share some similarities. All three films involve a   \n    central conflict that requires the main characters to overcome significant challenges. In \"E.T.\", the   \n    child must help the alien return home, in \"Jaws\", the characters must hunt down a dangerous shark, and  \n    in \"The Princess Bride\", the farmboy-turned-pirate must overcome obstacles to reunite with his love.    \n    Each movie also explores themes of courage, friendship, and determination. Furthermore, they are all    \n    iconic films that have left a significant impact on popular culture.                                    \n</code></pre> <p>As you can see, the <code>END</code> task has a lot more detail in it now. We're getting great summaries of the films, and therefore the output is even more detailed and valuable.</p> <p>Experiment</p> <p>You could enhance this output by providing more detail to the prompt compare prompt. For example, instead of just asking how they're the same, some options:</p> <ul> <li>\"Act as a movie critic. Why are these movies relevant to society?\"</li> <li>\"Act as a film studies professor. What are common themes in these movies?\"</li> </ul> <p>Hot Tip</p> <p>Instead of modifying the prompt, try using Rules and Rulesets to give your workflow more specific behavior.</p> <p>You can learn about Rulesets in the Multi Persona Chatbot course. </p>"},{"location":"courses/compare-movies-workflow/05_using_tools/#code-review","title":"Code Review","text":"<p>We added some of helpful functionality in this section, mainly getting wonderful descriptions of these films from the web by using the <code>WebScraper</code> tool and <code>ToolkitTasks</code>.</p> <p>Review your code.</p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape\nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper, TaskMemoryClient\n\nload_dotenv()\n\n# Create the workflow object\nworkflow = Workflow()\n\n\n# Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\nend_task = PromptTask(\n    \"\"\"\n    How are these movies the same:\n     {% for value in parent_outputs.values() %} \n     {{ value }}\n     {% endfor %}\n    \"\"\",\n    id=\"END\",\n)\n\n# Create a list of movie descriptions\nmovie_descriptions = [\n    \"A boy discovers an alien in his back yard\",\n    \"A shark attacks a beach\",\n    \"A princess and a man named Wesley\",\n]\n\n# Add tasks to workflow\nworkflow.add_task(start_task)\nworkflow.add_task(end_task)\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }}\",\n        context={\"description\": description},\n    )\n    summary_task = ToolkitTask(\n        \"Use metacritic to get a summary of this movie: {{ parent_outputs.values() | list |last }}\",\n        tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n    )\n\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n    workflow.insert_tasks(movie_task, [summary_task], end_task)\n\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"courses/compare-movies-workflow/05_using_tools/#next-step","title":"Next Step","text":"<p>Congratulations, we've got a working movie comparison application! We can add a list of movies to compare, and the result is a detailed comparison that provides valuable insight as to how these movies can impact society.</p> <p>However, we're currently only viewing the results in the logs. If we want to use this data inside an application, we need to get the output of the workflow.</p> <p>In the next section, we'll learn how Workflows handle the output of their tasks and grab just the value of the summary task. Saunter over to Workflow Outputs when you're ready.</p>"},{"location":"courses/compare-movies-workflow/06_workflow_outputs/","title":"Workflow Outputs","text":""},{"location":"courses/compare-movies-workflow/06_workflow_outputs/#overview","title":"Overview","text":"<p>In the previous section we added a <code>ToolkitTask</code> that used the <code>WebScraper</code> and <code>TaskMemoryClient</code> tools to get detailed information about the movies presented.</p> <p>In this section, we'll add the ability to get the <code>output</code> from the <code>workflow</code> in order to integrate it with whatever application we may be building.</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        C(\"ToolkitTask: Summary Task 1\"):::tool\n        H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\" ):::tool-dash\n        I(\"PromptTask: End\"):::main\n        J([\"\\n  Incredible movie insights. \\n\\n\"]):::output\n        A --&gt; B --&gt; C --&gt; I --&gt; J\n        A --&gt; G --&gt; H --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#333,stroke:#555\n</code></pre>"},{"location":"courses/compare-movies-workflow/06_workflow_outputs/#workflow-output_task","title":"Workflow Output_Task","text":"<p>Looking at our current workflow, you can see that there's one last task - the <code>End</code> task. Ideally we can run the workflow and get the output of this last task.</p> <p>Every task in Griptape has an attribute on it called <code>output_task</code>. If you took the Converational Chatbot course, you would have seen it when customizing the output of the agent.</p> <p>We can use this <code>output_task</code> of the <code>workflow</code> to get the final output value.</p> <pre><code>#...\n# Run the workflow\nworkflow.run()     \n\nprint(workflow.output_task.output.value)\n</code></pre>"},{"location":"courses/compare-movies-workflow/06_workflow_outputs/#test","title":"Test","text":"<p>Execute the code and let's review the output.</p> <pre><code>While these movies - \"E.T. the Extra-Terrestrial\", \"Jaws\", \nand \"The Princess Bride\" - have different plots and settings, \nthey share some common elements. All three films involve \ncharacters facing significant challenges and overcoming them. \nThey also all involve elements of adventure and suspense. \nAdditionally, they were all released in the 20th century and \nhave become iconic films in American cinema.\n</code></pre>"},{"location":"courses/compare-movies-workflow/06_workflow_outputs/#code-review","title":"Code Review","text":"<p>In this final section we learned out to get the <code>output</code> from the <code>workflow</code> in order to be able to integrate this workflow into our application.</p> <p>Review your code.</p> app.py<pre><code>from dotenv import load_dotenv\n\n# Griptape\nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper, TaskMemoryClient\n\nload_dotenv()\n\n# Create the workflow object\nworkflow = Workflow()\n\n\n# Create tasks\nstart_task = PromptTask(\"I will provide you a list of movies to compare.\", id=\"START\")\nend_task = PromptTask(\n    \"\"\"\n    How are these movies the same:\n     {% for value in parent_outputs.values() %} \n     {{ value }}\n     {% endfor %}\n    \"\"\",\n    id=\"END\",\n)\n\n# Create a list of movie descriptions\nmovie_descriptions = [\n    \"A boy discovers an alien in his back yard\",\n    \"A shark attacks a beach\",\n    \"A princess and a man named Wesley\",\n]\n\n# Add tasks to workflow\nworkflow.add_task(start_task)\nworkflow.add_task(end_task)\n\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }}\",\n        context={\"description\": description},\n    )\n    summary_task = ToolkitTask(\n        \"Use metacritic to get a summary of this movie: {{ parent_outputs.values() | list |last }}\",\n        tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n    )\n\n    workflow.insert_tasks(start_task, [movie_task], end_task)\n    workflow.insert_tasks(movie_task, [summary_task], end_task)\n\n# Run the workflow\nworkflow.run()\n\n# View the output\nprint(workflow.output_task.output.value)\n</code></pre>"},{"location":"courses/compare-movies-workflow/06_workflow_outputs/#next-step","title":"Next Step","text":"<p>But wait.. don't stop yet!</p> <p>There's new bonus material we've recently added that helps you understand the structure of your workflow!</p> <p>Head over to the next section: Workflow Display Graphs to learn how to understand the structure of your graph while you create it.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/","title":"Workflow Displaying the Graph","text":""},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#overview","title":"Overview","text":"<p>Throughout the course you've been creating Workflows by adding and inserting various tasks.</p> <p>We've been displaying those workflow structures in this documentation by using the extremely helpful Mermaid javascript libray.</p> <pre><code>graph TB \n    subgraph \" \"\n        direction TB\n        A(\"PromptTask: Start\"):::main \n        B(\"PromptTask: Movie Task 1\")\n        G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n        C(\"ToolkitTask: Summary Task 1\"):::tool\n        H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\" ):::tool-dash\n        I(\"PromptTask: End\"):::main\n        J([\"\\n  Incredible movie insights. \\n\\n\"]):::output\n        A --&gt; B --&gt; C --&gt; I --&gt; J\n        A --&gt; G --&gt; H --&gt; I\n    end\n\n    classDef main fill:#4274ff1a, stroke:#426eff\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#333,stroke:#555\n</code></pre> <p>While this is handy to help visualize Workflows while we discuss them, it would certainly be helpful to be able to get a better understanding of Workflows while you create them.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#the-to_graph-method","title":"The to_graph method","text":"<p>The Workflow class has a method on it called <code>to_graph</code>. This method outputs the graph you created as a Python dict.</p> <p>Let's modify our code slightly to print out the dictionary.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#displaying-the-graph","title":"Displaying the graph","text":""},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#import-rich-rprint","title":"Import rich rprint","text":"<p>Since we're going to be printing a dict, it would be nice to make it relatively easy to read. We can use the <code>rich</code> library's <code>rprint</code> function to do this.</p> <p>At the top of your script, add the following import statement: <pre><code>from dotenv import load_dotenv\nfrom rich import print as rprint\n\n# ...\n</code></pre></p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#comment-out-workflowrun","title":"Comment out workflow.run()","text":"<p>In order to see the graph hierarchy, you don't need to run the workflow. So let's temporarily comment it out in our code. Find the <code>workflow.run()</code> line at the bottom of your script and comment it out.</p> <pre><code># ...\n\n# Run the workflow\n# workflow.run()\n</code></pre>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#use-the-to_graph-method","title":"Use the to_graph method","text":"<p>After the commented out <code>workflow.run()</code> line, add the following lines:</p> <pre><code># ...\n# workflow.run()\n\n# use the to_graph method to return the graph\ngraph = workflow.to_graph()\n\n# print the graph\nrprint(graph)\n</code></pre>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#test","title":"Test","text":"<p>Run your code to see the result. It should look something like: <pre><code>{\n    'START': set(),\n    '31d300f8678c41f7ad31ff62cc58d95a': {'START'},\n    '4072265abb64464f816fd15383c82020': {'31d300f8678c41f7ad31ff62cc58d95a'},\n    'aea3bb1b14d74298bf32fa91e9ad2815': {'START'},\n    '8549fa7954014b0eb13099a6a0612517': {'aea3bb1b14d74298bf32fa91e9ad2815'},\n    'acf4926d80f14a0f84d813ceef1ff3c0': {'START'},\n    '7224e9aef92e40728828d7e9a2304ef2': {'acf4926d80f14a0f84d813ceef1ff3c0'},\n    'END': {'7224e9aef92e40728828d7e9a2304ef2', '8549fa7954014b0eb13099a6a0612517', '4072265abb64464f816fd15383c82020'}\n}\n</code></pre></p> <p>Now this probably isn't what you were expecting - it's not super clear what the node hierarchy is, and those numbers don't give a lot of context.</p> <p>Essentially what you're looking at is a list of <code>task ids</code> and their <code>parent task ids</code>.</p> <p>For example, this line: <code>'acf4926d80f14a0f84d813ceef1ff3c0': {'START'},</code> says that the Task with id <code>acf4926d80f14a0f84d813ceef1ff3c0</code> has a parent of the  task with the id <code>START</code>.</p> <p>Notice the <code>END</code> task has 3 nodes that are it's parent: <code>'7224e9aef92e40728828d7e9a2304ef2', '8549fa7954014b0eb13099a6a0612517', '4072265abb64464f816fd15383c82020'</code>.</p> <p>Still not making sense? That's okay, let's clean up these task id names and things will become a little clearer.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#clean-up-the-node-ids","title":"Clean up the node IDs","text":"<p>The first thing we'll want to do is make sure that each Task has a unique ID that's a litte clearer to understand. This means we'll be adding an <code>id</code> attribute to the <code>movie_task</code> and the <code>summary_task</code>.</p> <p>Find the section of the code where we create the <code>movie_task</code>. We're going to add an <code>id</code> attribute to it. However, we can't just give it a value of \"movie_task\" - or each movie PromptTask will have the same id. This is not allowed with Workflows - each task needs to be unique.</p> <p>We could label the tasks something like \"movie_task_1\", \"movie_task_2\", etc.. but it might be nicer to make it a little clearer what each one does.</p> <p>So what if we used a bit of the description to describe the task? Something like:</p> <ul> <li><code>TITLE: A princes...</code></li> <li><code>TITLE: A shark at...</code></li> </ul> <p>So we can tell just by glancing at what each task represents.</p> <pre><code># ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    movie_task = PromptTask(\n        \"What movie title is this? Return only the movie name: {{ description }}\",\n        context={\"description\": description},\n        id=f\"TITLE: {description[:10]}..\", # Use the first 10 characters of the description\n    )\n\n# ...\n</code></pre> <p>Execute that and look at the result:</p> <pre><code>{\n    'START': set(),\n    'TITLE: A princess...': {'START'},\n    'c9ce1d1f7da54fa299dba9a84ebe7ccb': {'TITLE: A princess...'},\n    'TITLE: A shark at...': {'START'},\n    '69c2b414649d42e690a505981ef4979f': {'TITLE: A shark at...'},\n    'TITLE: A boy disc...': {'START'},\n    '08ef43cfda28416c91fedf2d3b43cdd5': {'TITLE: A boy disc...'},\n    'END': {'c9ce1d1f7da54fa299dba9a84ebe7ccb', '69c2b414649d42e690a505981ef4979f', '08ef43cfda28416c91fedf2d3b43cdd5'}\n}\n</code></pre> <p>Notice how it's a little easier to understand? Let's do the same for the <code>summary_task</code>. Modify that ToolkitTask to have an id as well, and this time use the same description so we can see how the tasks are related:</p> <pre><code># ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n    # ...\n\n    summary_task = ToolkitTask(\n        \"Use metacritic to get a summary of this movie: {{ parent_outputs.values() | list |last }}\",\n        tools=[WebScraper(), TaskMemoryClient(off_prompt=False)],\n        id=f\"SUMMARY: {description[:10]}...\"\n    )\n\n# ...\n</code></pre> <p>The results are definitely clearer:</p> <pre><code>{\n    'START': set(),\n    'TITLE: A princess...': {'START'},\n    'SUMMARY: A princess...': {'TITLE: A princess...'},\n    'TITLE: A shark at...': {'START'},\n    'SUMMARY: A shark at...': {'TITLE: A shark at...'},\n    'TITLE: A boy disc...': {'START'},\n    'SUMMARY: A boy disc...': {'TITLE: A boy disc...'},\n    'END': {'SUMMARY: A boy disc...', 'SUMMARY: A shark at...', 'SUMMARY: A princess...'}\n}\n</code></pre> <p>So looking at this, you can see that <code>START</code> is the first item because it has no parents (identified with: <code>set()</code>).</p> <p>The three <code>TITLE: ...</code> tasks are a parent of <code>START</code> and the <code>SUMMARY</code> tasks are children of their respective <code>TITLE</code> tasks.</p> <p>The <code>END</code> task has 3 parents - the <code>SUMMARY</code> tasks.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#display-with-nodes","title":"Display with nodes","text":"<p>This is fine for quick cases, but wouldn't it be better if you could actually display the graph in an easier to read way - similar to how we're using mermaid.js in this course?</p> <p>That's exactly what we're going to do. We'll create a utility we can use on Workflows to display the nodes just like we would with mermaid.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#create-a-display_graphpy-file","title":"Create a display_graph.py file","text":"<p>Save the following Python file as <code>display_graph.py</code> in the same directory as your <code>app.py</code>.</p> <pre><code>\"\"\"\nMermaid Graph Display Utility\n\nThis utility allows for the visualization of Workflow Graphs\nusing Mermaid.js. It generates an HTML page with a Mermaid graph based on a\ngiven graph data structure and opens it in the default web browser.\n\nUsage:\n    from display_graph import display_graph\n    display_graph(your_data)\n\nRequirements:\n    - Internet connection for Mermaid.js CDN.\n    - A web browser to view the generated graph.\n\nAuthor: jason@griptape.ai\nDate: Nov 15, 2023\nVersion: 1.0\n\"\"\"\n\nimport webbrowser\nimport os\nimport string\nfrom typing import Dict, Set\n\n\n# Create unique identifiers for each node in the graph\ndef generate_identifiers(nodes):\n    id_generator = iter(string.ascii_uppercase)\n    return {node: next(id_generator) for node in nodes}\n\n\n# Convert the graph data to mermaid format\ndef convert_to_mermaid(data: Dict[str, Set[str]], identifiers: Dict[str, str]) -&gt; str:\n    mermaid_graph = \"graph TD\\n\"\n    for child, parents in data.items():\n        child_id = identifiers[child]\n        if not parents:\n            mermaid_graph += f'    {child_id}(\"{child}\")\\n'\n        for parent in parents:\n            parent_id = identifiers[parent]\n            mermaid_graph += f'    {parent_id}(\"{parent}\") --&gt; {child_id}(\"{child}\")\\n'\n    return mermaid_graph\n\n\n# Create the HTML content for the graph\ndef html_content(mermaid_graph: str) -&gt; str:\n    return f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Mermaid Graph&lt;/title&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;mermaid.initialize({{ theme: 'dark', startOnLoad: true }});&lt;/script&gt;\n        &lt;style&gt;\n            body {{\n        background-color: rgb(30, 33, 41);\n        color: rgba(226, 228, 233, 0.82);\n            }}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"mermaid\"&gt;\n            {mermaid_graph}\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n\n# Display the graph in a web browser\ndef display_graph(data: Dict[str, Set[str]]):\n    identifiers = generate_identifiers(data.keys())\n    mermaid_graph = convert_to_mermaid(data, identifiers)\n\n    file_path = \"graph.html\"\n    with open(file_path, \"w\") as file:\n        file.write(html_content(mermaid_graph))\n\n    webbrowser.open(\"file://\" + os.path.realpath(file_path))\n</code></pre>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#use-display_graph-to-display-your-workflow-graph","title":"Use display_graph to display your workflow graph","text":"<p>Inside your <code>app.py</code>, you will need to first <code>import</code> the <code>display_graph</code> function.</p> <p>At the top of your script, add the following import: <pre><code>from display_graph import display_graph\n</code></pre></p> <p>Now at the bottom of your script, instead of using <code>rprint</code> to print out your graph, use <code>display_graph</code></p> <pre><code># ...\n# workflow.run()\n\n# use the to_graph method to return the graph\ngraph = workflow.to_graph()\n\n# print the graph\ndisplay_graph(graph)\n</code></pre> <p>Execute your script and you should see an html page appear with your graph!</p> <p></p> <p>Feel free to use this any time you need to quickly display your graph as it's being built.</p>"},{"location":"courses/compare-movies-workflow/07_workflow_display_graph/#finished","title":"Finished","text":"<p>Success</p> <p>Congratulations! You have created a successful Griptape Workflow!</p> <p>Well done, you've successfully created a Griptape Workflow that allows you to execute complex and interesting dependency graphs.</p> <p>You have learned how to:</p> <ul> <li>Create tasks that can handle prompts and tools.</li> <li>Learned a bit about Jinja2 templates.</li> <li>Create parent/child relationships.</li> <li>Create tasks that are depending on multiple incoming tasks.</li> <li>Get the output from a workflow for integration with other applications.</li> <li>Understand the graph being created by displaying it with various methods.</li> </ul> <p>We hope you enjoyed this course, and look forward to seeing what you're able to create with these new skills.</p>"},{"location":"setup/","title":"Setting Up Your Python Environment for Griptape","text":""},{"location":"setup/#kickoff-and-foundations","title":"Kickoff and Foundations","text":"<p>Welcome to the getting started course for Griptape. We'll be using Visual Studio Code and the Griptape library, which make a great combo for coding with Large Language Models (LLMs).</p>"},{"location":"setup/#what-will-i-learn","title":"What will I learn?","text":"<p>By the end of the course you will have the ability to use Griptape to work with Large Language Models. You will be setting up your Python environment, install a code editor, install Griptape, and be ready to go.</p> griptape_developer.py<pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\n\nload_dotenv()\n\n# Create an agent\nagent = Agent()\n\n# Run the agent\nagent.run(\"Hello! I'm a new Griptape Developer!\")\n</code></pre>"},{"location":"setup/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at beginners to intermediate level Python developers who are interested in setting up a Python environment to develop tools and applications with Griptape.</p>"},{"location":"setup/#why-visual-studio-code","title":"Why Visual Studio Code?","text":"<p>Using the right coding software (or Integrated Development Environment - IDE) can make your coding sessions a breeze... or not (if you choose the wrong one).</p> <p>Visual Studio Code (VS Code for short) is our IDE of choice for a few reasons. It's lightweight, highly customizable, and has a vast range of extensions.</p>"},{"location":"setup/#griptape-and-python","title":"Griptape and Python","text":"<p>Griptape provides a simple, Pythonic interface to interact with these models, taking care of the complexities so we can focus on coding our applications.</p> <p>In the next stages, we will be going through:</p> <ul> <li> <p>Setting Up: Here, we will install and set up the basic tools we need: Visual Studio Code, Python, and create our directory structure. We'll also ensure that you have the right Python environment in place.</p> </li> <li> <p>OpenAI API Key: Before jumping into Griptape, we need to get our OpenAI API Key and set up our environment so it's ready.</p> </li> <li> <p>Griptape: We'll install the Griptape library and send our first message to the LLM!</p> </li> </ul> <p>Are you ready to get started? Let's move on to Setting up your environment!</p>"},{"location":"setup/01_setting_up_environment/","title":"Software","text":""},{"location":"setup/01_setting_up_environment/#overview","title":"Overview","text":"<p>Setting up our development environment correctly is vital for smooth and successful coding. In this stage, we'll go through all the necessary installations and configurations.</p>"},{"location":"setup/01_setting_up_environment/#installing-python","title":"Installing Python","text":"<p> Before getting started with Griptape, you'll need to install Python. We currently recommend a Python version less than 3.12.</p> <p>Info</p> <p>Griptape requires a Python version between <code>3.11</code> and less than <code>3.12</code>. We're working on updates to this and will update this course when that changes.</p>"},{"location":"setup/01_setting_up_environment/#windows-or-linux","title":"Windows or Linux","text":"<ol> <li>Head over to the official Python downloads page</li> <li>Click on the button that says \"Python 3.11.x\" (or the most recent 3.11 version) to download the installer</li> <li>Run the installer, and make sure to check the box that says \"Add Python to environment variables\" before you click \"Install\"</li> </ol>"},{"location":"setup/01_setting_up_environment/#macos","title":"macOS","text":"<p>If you have Homebrew installed:</p> <ol> <li>Open your terminal</li> <li>Run the <code>command brew install python@3.11</code></li> <li>After the installation is complete, run <code>brew link python@3.11</code></li> </ol> <p>Info</p> <p>If you don't have Homebrew, you can install Python from the official website as mentioned above.</p> <p>You did it!</p> <p>Congratulations, you've got Python!</p>"},{"location":"setup/01_setting_up_environment/#visual-studio-code","title":"Visual Studio Code","text":""},{"location":"setup/01_setting_up_environment/#installing","title":"Installing","text":"<p>Visual Studio Code (VS Code) provides the perfect environment for our Python coding.</p> <ol> <li>Go to the VS Code download page</li> <li>Download the version appropriate for your OS (Windows, Linux, or macOS)</li> <li>Run the installer and follow the prompts</li> </ol> <p>Success</p> <p>VS Code is now installed!</p>"},{"location":"setup/01_setting_up_environment/#creating-the-project-folder","title":"Creating the Project Folder","text":"<p>Before we dive into coding, let's create a dedicated space for our project. Having a clean organized directory structure makes coding and managing your projects much easier.</p> <p>First, you'll want to create a new folder on your computer where all the code for this project will live. You can create this folder anywhere you like. Here's how you can do it via your Terminal:</p> <pre><code>mkdir griptape-starter\ncd griptape-starter\n</code></pre> <p>This creates a new folder called \"griptape_intro\" and moves into it.</p> <p>Alternatively, feel free to open up Visual Studio Code and create a new folder:</p> <ol> <li>Choose File -&gt; Open Folder..</li> <li>Choose New Folder</li> <li>Enter the name of your new folder. Example: <code>griptape-starter</code></li> <li>Choose Create</li> <li>Double-click on the newly created folder to open it.</li> </ol>"},{"location":"setup/01_setting_up_environment/#python","title":"Python","text":""},{"location":"setup/01_setting_up_environment/#installing-vs-code-python-extension","title":"Installing VS Code Python Extension","text":"<p>The Python extension for Visual Studio Code provides rich support for the Python language, including features like IntelliSence, linting, debugging, code formatting, and more. It really makes life easier for Python developers.</p> <ol> <li>With VS Code open, go to the Extensions tab, or choose View --&gt; Extensions</li> <li>Search for <code>Python</code>, or go to [Python]((https://marketplace.visualstudio.com/items?itemName=ms-python.python) in your web browser.</li> <li>Choose <code>Install</code>.</li> <li>Open the command Palette (<code>Ctrl</code>+<code>Shift</code>+<code>P</code> on Windows/Linux, <code>Cmd</code>+<code>Shift</code>+<code>P</code> on macOS), or choose View --&gt; Command Palette..</li> <li>Type <code>Python</code> and you should see a list of specific commands for Python. This will confirm that the install was sucessful.</li> </ol> <p></p>"},{"location":"setup/01_setting_up_environment/#virtual-environments","title":"Virtual Environments","text":""},{"location":"setup/01_setting_up_environment/#using-vs-codes-python-environment-manager","title":"Using VS Code's Python Environment Manager","text":"<p>Python virtual environments are essential tools for keeping your projects organized and isolated. They allow each project to have its own set of dependencies, ensuring that different projects won't interfere with each other, which is vital when different projects require different versions of the same library. By using virtual environments, you can maintain a clean, conflict-free workspace for each project, making it easier to manage your code and troubleshoot any issues.</p> <p>Many developers use their terminal to manage their Python virtual environments. As this is a beginner level course, we'll use an Extension inside VS Code instead because it makes this a little bit easier.</p> <ol> <li>With VS Code open, go to the Extensions tab, or choose View --&gt; Extensions</li> <li>Search for <code>Python Environment Manager</code>, or go to Python Environment Manager in your web browser.</li> <li>Choose <code>Install</code>.</li> <li>Open the Command Palette (<code>Ctrl</code>+<code>Shift</code>+<code>P</code> on Windows/Linux, <code>Cmd</code>+<code>Shift</code>+<code>P</code> on macOS), or choose View --&gt; Command Palette..</li> <li> <p>Search for <code>Python: Create Environment</code> and you should see it come up at the top of the command list.    </p> </li> <li> <p>Hit return with that item selected and choose <code>.Venv: Creates a '.venv' virtual environment in the current workspace</code></p> </li> </ol> <p></p> <ol> <li>Then choose a python version.</li> </ol> <p></p> <p>Note: This will create the virtual environment for you within the current directory.</p> <ul> <li>This creates a new virtual environment in a folder called <code>.venv</code> and activates the environment for you.</li> </ul> <p>Now you've set up your Python environment for this project. This way, anything you install or change in Python won't affect other projects.</p>"},{"location":"setup/01_setting_up_environment/#confirm-its-working","title":"Confirm it's working","text":"<p>To be sure that your virtual environment is set up correctly, we'll check by opening a Terminal. If everything is set correctly, you'll see <code>.venv</code> in your terminal prompt.</p> <ol> <li>Open the terminal in VS Code by clicking on <code>Terminal -&gt; New Terminal</code></li> </ol> <p></p> <p>Note</p> <p>You should see <code>.venv</code> in your prompt. If you don't see it, please run through the previous documentation to try again, or check out the TroubleShooting section of this tutorial.</p>"},{"location":"setup/01_setting_up_environment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setup/01_setting_up_environment/#execution-policy","title":"Execution Policy","text":"<p>On some Windows systems, you may get an error that says something similar to:</p> <p>Failure</p> <p>.venv\\Scripts\\Activate.ps1 cannot be loaded because running scripts is disabled on this system.</p> <p>This is due to an execution policy. Don't worry, it's pretty easy to resolve.</p> <ol> <li>With the Terminal open, execute the following command:</li> </ol> <pre><code>Set-ExecutionPolicy -Scope CurrentUser Unrestricted\n</code></pre> <ul> <li> <p>This will give the current user the ability to run scripts from within Visual Studio Code.</p> </li> <li> <p>Verify this worked by closing the Terminal and re-opening it. You should be able to execute scripts now without any errors.</p> </li> </ul> <p>Info</p> <p>You can learn more about Windows Execution Policies in the Set-ExecutionPolicy documentation.</p>"},{"location":"setup/01_setting_up_environment/#next-step","title":"Next Step","text":"<p>You now have Python and VS Code installed, and you've got a working virtual environment! In the next section, we'll set up your OpenAI API key so you can communicate with their large language model.</p>"},{"location":"setup/02_openai/","title":"OpenAI","text":""},{"location":"setup/02_openai/#overview","title":"Overview","text":""},{"location":"setup/02_openai/#openai","title":"OpenAI","text":""},{"location":"setup/02_openai/#obtaining-the-api-key","title":"Obtaining the API Key","text":"<p>In order to communicate with an LLM using Griptape, we'll need a key. To do this, we'll grab an API key from OpenAI.</p> <p>Tip</p> <p>Griptape can work with many large language models, but to keep things simple for now, we'll just focus on OpenAI's gpt model.</p> <ol> <li>Go to the OpenAI website and sign up for an account if you don't have one already.</li> <li> <p>After logging in, navigate to the API section of your dashboard.</p> <p></p> </li> <li> <p>Choose Create a new secret key in order to create a key for your use.</p> </li> <li> <p>Give your key a name. Example: <code>griptape</code></p> <p></p> </li> <li> <p>Choose Create secret key</p> </li> <li> <p>You will see a window with your new key highlighted. You will not be able to view this key again so it's very important to copy the key and save it somewhere safe.</p> <p></p> </li> <li> <p>Choose Done</p> </li> </ol> <p>Warning</p> <p>Remember, this API key is like your secret key to the city of LLMs. Don't share it with anyone!</p>"},{"location":"setup/02_openai/#installing-python-dotenv","title":"Installing python-dotenv","text":"<p>Understanding and using environment variables is a key aspect of programming. In order to use the API key we just received, we will need to be able to access it from with our python script. We'll use a package called python-dotenv to handle environment variables in our project.</p> <p>In the terminal, run the command <code>pip install python-dotenv</code> to install the package. </p> <p>Info</p> <p>You can learn more about pip and python-dotenv by visiting their PyPi page: https://pypi.org/project/python-dotenv/.</p> <p></p>"},{"location":"setup/02_openai/#creating-the-env-file-and-setting-the-openai-api-key","title":"Creating the .env File and Setting the OpenAI API Key","text":"<p>Now that we have our OpenAI API key, we need to make it available for our Python code to use. The best and safest way to do this is using a <code>.env</code> file, which allows us to define environment variables. We can then use the <code>load_dotenv</code> library to access any of those environment variables..</p> <ol> <li>In the root of your project folder (<code>griptape-starter</code>), create a new file and name it <code>.env</code>.</li> <li>Open the <code>.env</code> file and write <code>OPENAI_API_KEY=your_openai_api_key_here</code>, replacing <code>your_openai_api_key_here</code> with your actual OpenAI API key.</li> <li>Save the file.</li> </ol> .env<pre><code>OPENAI_API_KEY=your_openai_api_key_here \n</code></pre>"},{"location":"setup/02_openai/#your-first-app","title":"Your first app","text":""},{"location":"setup/02_openai/#creating-apppy","title":"Creating app.py","text":"<p>Now we're going to create our Python file and use the <code>python-dotenv</code> library to load the <code>OPENAI_API_KEY</code> environment variable. First things first, let's create a Python file where we will write our code.</p> <ol> <li>In your project directory (<code>griptape-starter</code>), create a new file called <code>app.py</code>. You can do this in VS Code by clicking <code>File -&gt; New File</code></li> <li>Save the file by choosing <code>File -&gt; Save As...</code></li> <li>Entering <code>app.py</code> as the filename.</li> </ol> <p>Success</p> <p>Nice, you've created your first Python file! </p>"},{"location":"setup/02_openai/#importing-the-library","title":"Importing the Library","text":"<p>Next, we're going to import the <code>load_dotenv</code> function from the <code>dotenv</code> library we installed earlier.</p> <p>Enter the following code in app.py.</p> app.py<pre><code>from dotenv import load_dotenv\n</code></pre>"},{"location":"setup/02_openai/#loading-the-variables","title":"Loading the variables","text":"<p>Now we'll use the <code>load_dotenv</code> function. Update your <code>app.py</code> with the highlighted line: app.py<pre><code>from dotenv import load_dotenv\n\nload_dotenv() # Load the environment variables\n</code></pre></p> <p>If you save and run your script, you shouldn't get any errors in your Terminal. If you received no errors.. you win! You've loaded your environment variable that was specified in the <code>.env</code> file!</p>"},{"location":"setup/02_openai/#next-steps","title":"Next Steps","text":"<p>Congratulations! Your environment is set, and your application is ready. You're ready to start using Griptape! In the next section, we'll install Griptape and send our first message to the LLM. I wonder what it'll say...</p>"},{"location":"setup/03_griptape/","title":"Griptape","text":""},{"location":"setup/03_griptape/#overview","title":"Overview","text":"<p>Now that you've got your environment all set up, it's time to actually start moving. In this stage, we'll put together a basic Griptape application and see it in action. </p>"},{"location":"setup/03_griptape/#our-application","title":"Our Application","text":"<p>We are going to build a very simple application. It's going to simply take in a prompt, and return the result of that prompt. For example, we will be able to ask: \"What's a good place to visit in New Zealand?\" and it will give us an answer like \"Abel Tasman\" or \"All of it\".</p>"},{"location":"setup/03_griptape/#griptape","title":"Griptape","text":""},{"location":"setup/03_griptape/#agents","title":"Agents","text":"<p>There are multiple ways communicate with LLMs via Griptape, but the one we'll use in this example is an Agent. You can learn more about Agents in documentation, but here's a simple way to understand them:</p> <p>Abstract</p> <p>Agents can do one task.</p> <p>You give the Agent a prompt, it thinks for a bit, figures things out, and then returns a result. While that sounds relatively simple, it's actually quite cool. You can give the agent tools (WebScraper, Calculator, EmailClient, to name a few), you can give it rules about how to behave, and more. Agents can actually do quite a lot - but they're still one of the more simple ways of interacting with Griptape, which is why we'll use them to start with in this course.</p> <p>Speaking of interacting with Griptape... we need to install it!</p>"},{"location":"setup/03_griptape/#installing-griptape","title":"Installing Griptape","text":"<p>Just like we installed the <code>python_dotenv</code> library, we need to do the same with Griptape. </p> <p>Open your Terminal and use <code>pip</code> to install <code>griptape</code>:</p> <pre><code>pip install griptape\n</code></pre> <p>Info</p> <p>This will take a minute to install. Another chance to enjoy a !</p>"},{"location":"setup/03_griptape/#import-griptape","title":"Import Griptape","text":"<p>Now comes the moment you've all been waiting for! Actually, it's the moment before the moment. In this moment, we're going to import the Agent from the Griptape library. The moment after that is probably the one you're really waiting for. But we have to do this moment first. Live in the now.</p> <p>Modify your <code>app.py</code> to import the agent</p> app.py<pre><code>from dotenv import load_dotenv\n\nfrom griptape.structures import Agent\n\nload_dotenv() # Load the environment variables\n</code></pre> <p>As you can see, we're importing the Agent from <code>griptape.structures</code>. There are other structures we can work with, but again.. this is just setting up your environment. We'll talk about those in another course.</p>"},{"location":"setup/03_griptape/#the-fun-part","title":"The fun part","text":""},{"location":"setup/03_griptape/#create-the-agent","title":"Create the Agent","text":"<p>To create the Agent, we'll instantiate the class. </p> app.py<pre><code>from dotenv import load_dotenv\n\nfrom griptape.structures import Agent\n\nload_dotenv() # Load the environment variables\n\n# Create the Agent\nagent = Agent()\n</code></pre>"},{"location":"setup/03_griptape/#run-the-agent","title":"Run the Agent","text":"<p>Now you get to tell the Agent what to do. Use the Agent's <code>run</code> method to execute a prompt.</p> app.py<pre><code>from dotenv import load_dotenv\n\nfrom griptape.structures import Agent\n\nload_dotenv() # Load the environment variables\n\n# Create the Agent\nagent = Agent()\n\n# Run the agent\nagent.run(\"Give me a haiku about skateboarding\")\n</code></pre>"},{"location":"setup/03_griptape/#test-the-agent","title":"Test the Agent","text":"<p>Let's see if our application works.</p> <ol> <li>Save your file.</li> <li>Use the Run icon in the upper right corner of VS Code, or open your terminal and type <code>python app.py</code>.</li> </ol> <p>If everything has been set up correctly, you should see the result of the <code>agent.run()</code> command printed in the terminal. The exact output will depend on the current configuration and performance of the OpenAI API, but it should be a haiku about skateboarding.</p> <pre><code>[07/21/23 05:39:22] INFO     Task 801254fc5df64cda8930917a8afbc5bc                                              \n                             Input: Create me a haiku about skateboarding                                       \n[07/21/23 05:39:24] INFO     Task 801254fc5df64cda8930917a8afbc5bc                                              \n                             Output: Skateboard glides swiftly,                                                 \n                             Tricks and flips in the air, high,                                                 \n                             Thrilling ride, pure bliss.      \n</code></pre> <p>Success</p> <p>Congrats! You've taken the first push and created your first python script that works with a large language model!</p>"},{"location":"setup/03_griptape/#next-steps","title":"Next Steps","text":"<p>You've successfully set up your development environment, installed the necessary packages, obtained your OpenAI API key, and written and run a simple Griptape application. You've done a great job, so don't forget to celebrate your progress. </p> <p>Now that you've successfully completed the course, please check out these Helpful Resources to learn more about Griptape!</p>"},{"location":"setup/04_helpful_resources/","title":"Resources","text":"<p>Congrats on reaching this stage! You've set up your environment, written your first Griptape application, and are ready to embark on your coding journey. However, learning is an ongoing process, and the more resources you have at your disposal, the more empowered you'll be to tackle whatever comes your way.</p> <p>Here's a list of resources to help you gain momentum and build your knowledge:</p>"},{"location":"setup/04_helpful_resources/#griptape","title":"Griptape","text":"<ul> <li> <p>Griptape Documentation: Learn everything you need to know about Griptape from its official documentation. You'll find detailed explanations, ../assets/examples, and tips here. Visit the Griptape Documentation.</p> </li> <li> <p>Griptape GitHub: Check out the official Griptape repository on GitHub. You can look at the source code, report issues, and even contribute. Here's the Griptape GitHub link.</p> </li> <li> <p>Griptape Discord Community: Join the Griptape community on Discord. Here, you can connect with other users, ask questions, share your projects, and keep up-to-date with Griptape developments. Here's the Griptape Discord link.</p> </li> </ul>"},{"location":"setup/04_helpful_resources/#tools","title":"Tools","text":"<ul> <li> <p>Visual Studio Code: Brush up on your VS Code knowledge. Check out the VS Code Documentation to get familiar with its features and functionalities.</p> </li> <li> <p>Python: Python's official documentation is a comprehensive resource that covers all aspects of the language. Visit the Python Documentation.</p> </li> <li> <p>Python-dotenv: Get more information about how to use the python-dotenv package from its Python-dotenv PyPI page.</p> </li> <li> <p>OpenAI API: Understand how OpenAI's API works. The OpenAI API Documentation is a great place to start.</p> </li> </ul>"},{"location":"setup/04_helpful_resources/#additional-links","title":"Additional Links","text":"<ul> <li>Language Learning Models (LLMs): Get a broader understanding of LLMs and how they're revolutionizing the field of AI. Here are some useful links:</li> <li>What are Language Models?</li> <li>Language Learning Models Explained</li> </ul> <p>These resources will give you a deeper understanding and greater control as you navigate the landscape of programming with Python and Griptape. Happy coding!</p>"}]}